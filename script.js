const vocabularyThemes = {
    business: {
        name: "ë¹„ì¦ˆë‹ˆìŠ¤ ì˜ì–´",
        icon: "ğŸ’¼",
        words: [
            { word: "achieve", meaning: "ë‹¬ì„±í•˜ë‹¤", type: "ë™ì‚¬" },
            { word: "acquire", meaning: "íšë“í•˜ë‹¤", type: "ë™ì‚¬" },
            { word: "agreement", meaning: "í•©ì˜, ê³„ì•½", type: "ëª…ì‚¬" },
            { word: "budget", meaning: "ì˜ˆì‚°", type: "ëª…ì‚¬" },
            { word: "colleague", meaning: "ë™ë£Œ", type: "ëª…ì‚¬" },
            { word: "conference", meaning: "íšŒì˜", type: "ëª…ì‚¬" },
            { word: "deadline", meaning: "ë§ˆê°ì¼", type: "ëª…ì‚¬" },
            { word: "department", meaning: "ë¶€ì„œ", type: "ëª…ì‚¬" },
            { word: "efficient", meaning: "íš¨ìœ¨ì ì¸", type: "í˜•ìš©ì‚¬" },
            { word: "evaluate", meaning: "í‰ê°€í•˜ë‹¤", type: "ë™ì‚¬" },
            { word: "executive", meaning: "ì„ì›", type: "ëª…ì‚¬" },
            { word: "financial", meaning: "ì¬ì •ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "investment", meaning: "íˆ¬ì", type: "ëª…ì‚¬" },
            { word: "management", meaning: "ê´€ë¦¬", type: "ëª…ì‚¬" },
            { word: "negotiate", meaning: "í˜‘ìƒí•˜ë‹¤", type: "ë™ì‚¬" },
            { word: "opportunity", meaning: "ê¸°íšŒ", type: "ëª…ì‚¬" },
            { word: "profit", meaning: "ì´ìµ", type: "ëª…ì‚¬" },
            { word: "proposal", meaning: "ì œì•ˆì„œ", type: "ëª…ì‚¬" },
            { word: "strategy", meaning: "ì „ëµ", type: "ëª…ì‚¬" },
            { word: "supervisor", meaning: "ìƒì‚¬", type: "ëª…ì‚¬" },
            { word: "analysis", meaning: "ë¶„ì„", type: "ëª…ì‚¬" },
            { word: "corporate", meaning: "ê¸°ì—…ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "customer", meaning: "ê³ ê°", type: "ëª…ì‚¬" },
            { word: "develop", meaning: "ê°œë°œí•˜ë‹¤", type: "ë™ì‚¬" },
            { word: "economy", meaning: "ê²½ì œ", type: "ëª…ì‚¬" },
            { word: "entrepreneur", meaning: "ê¸°ì—…ê°€", type: "ëª…ì‚¬" },
            { word: "market", meaning: "ì‹œì¥", type: "ëª…ì‚¬" },
            { word: "productivity", meaning: "ìƒì‚°ì„±", type: "ëª…ì‚¬" },
            { word: "revenue", meaning: "ìˆ˜ìµ", type: "ëª…ì‚¬" },
            { word: "stakeholder", meaning: "ì´í•´ê´€ê³„ì", type: "ëª…ì‚¬" },
            { word: "consultant", meaning: "ì»¨ì„¤í„´íŠ¸", type: "ëª…ì‚¬" },
            { word: "franchise", meaning: "í”„ëœì°¨ì´ì¦ˆ", type: "ëª…ì‚¬" },
            { word: "innovation", meaning: "í˜ì‹ ", type: "ëª…ì‚¬" },
            { word: "partnership", meaning: "íŒŒíŠ¸ë„ˆì‹­", type: "ëª…ì‚¬" },
            { word: "quarterly", meaning: "ë¶„ê¸°ë³„", type: "í˜•ìš©ì‚¬" },
            { word: "sustainability", meaning: "ì§€ì†ê°€ëŠ¥ì„±", type: "ëª…ì‚¬" },
            { word: "transaction", meaning: "ê±°ë˜", type: "ëª…ì‚¬" },
            { word: "workflow", meaning: "ì—…ë¬´íë¦„", type: "ëª…ì‚¬" },
            { word: "benchmark", meaning: "ê¸°ì¤€ì ", type: "ëª…ì‚¬" },
            { word: "compliance", meaning: "ì¤€ìˆ˜", type: "ëª…ì‚¬" }
        ]
    },
    science: {
        name: "ê³¼í•™ ê¸°ìˆ ",
        icon: "ğŸ”¬",
        words: [
            { word: "analyze", meaning: "ë¶„ì„í•˜ë‹¤", type: "ë™ì‚¬" },
            { word: "atmosphere", meaning: "ëŒ€ê¸°", type: "ëª…ì‚¬" },
            { word: "biology", meaning: "ìƒë¬¼í•™", type: "ëª…ì‚¬" },
            { word: "chemistry", meaning: "í™”í•™", type: "ëª…ì‚¬" },
            { word: "data", meaning: "ë°ì´í„°", type: "ëª…ì‚¬" },
            { word: "evolution", meaning: "ì§„í™”", type: "ëª…ì‚¬" },
            { word: "experiment", meaning: "ì‹¤í—˜", type: "ëª…ì‚¬" },
            { word: "formula", meaning: "ê³µì‹", type: "ëª…ì‚¬" },
            { word: "genetics", meaning: "ìœ ì „í•™", type: "ëª…ì‚¬" },
            { word: "hypothesis", meaning: "ê°€ì„¤", type: "ëª…ì‚¬" },
            { word: "laboratory", meaning: "ì‹¤í—˜ì‹¤", type: "ëª…ì‚¬" },
            { word: "molecule", meaning: "ë¶„ì", type: "ëª…ì‚¬" },
            { word: "observation", meaning: "ê´€ì°°", type: "ëª…ì‚¬" },
            { word: "physics", meaning: "ë¬¼ë¦¬í•™", type: "ëª…ì‚¬" },
            { word: "research", meaning: "ì—°êµ¬", type: "ëª…ì‚¬" },
            { word: "scientific", meaning: "ê³¼í•™ì ì¸", type: "í˜•ìš©ì‚¬" },
            { word: "technology", meaning: "ê¸°ìˆ ", type: "ëª…ì‚¬" },
            { word: "theory", meaning: "ì´ë¡ ", type: "ëª…ì‚¬" },
            { word: "universe", meaning: "ìš°ì£¼", type: "ëª…ì‚¬" },
            { word: "variable", meaning: "ë³€ìˆ˜", type: "ëª…ì‚¬" },
            { word: "algorithm", meaning: "ì•Œê³ ë¦¬ì¦˜", type: "ëª…ì‚¬" },
            { word: "bacteria", meaning: "ë°•í…Œë¦¬ì•„", type: "ëª…ì‚¬" },
            { word: "catalyst", meaning: "ì´‰ë§¤", type: "ëª…ì‚¬" },
            { word: "database", meaning: "ë°ì´í„°ë² ì´ìŠ¤", type: "ëª…ì‚¬" },
            { word: "electron", meaning: "ì „ì", type: "ëª…ì‚¬" },
            { word: "fossil", meaning: "í™”ì„", type: "ëª…ì‚¬" },
            { word: "genome", meaning: "ê²Œë†ˆ", type: "ëª…ì‚¬" },
            { word: "hydrogen", meaning: "ìˆ˜ì†Œ", type: "ëª…ì‚¬" },
            { word: "innovation", meaning: "í˜ì‹ ", type: "ëª…ì‚¬" },
            { word: "junction", meaning: "ì ‘í•©ë¶€", type: "ëª…ì‚¬" },
            { word: "kinetic", meaning: "ìš´ë™ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "laser", meaning: "ë ˆì´ì €", type: "ëª…ì‚¬" },
            { word: "membrane", meaning: "ë§‰", type: "ëª…ì‚¬" },
            { word: "neutron", meaning: "ì¤‘ì„±ì", type: "ëª…ì‚¬" },
            { word: "organic", meaning: "ìœ ê¸°ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "protein", meaning: "ë‹¨ë°±ì§ˆ", type: "ëª…ì‚¬" },
            { word: "quantum", meaning: "ì–‘ì", type: "ëª…ì‚¬" },
            { word: "radiation", meaning: "ë°©ì‚¬ì„ ", type: "ëª…ì‚¬" },
            { word: "synthesis", meaning: "í•©ì„±", type: "ëª…ì‚¬" },
            { word: "velocity", meaning: "ì†ë„", type: "ëª…ì‚¬" }
        ]
    },
    travel: {
        name: "ì—¬í–‰ & êµí†µ",
        icon: "âœˆï¸",
        words: [
            { word: "accommodation", meaning: "ìˆ™ë°•ì‹œì„¤", type: "ëª…ì‚¬" },
            { word: "adventure", meaning: "ëª¨í—˜", type: "ëª…ì‚¬" },
            { word: "airport", meaning: "ê³µí•­", type: "ëª…ì‚¬" },
            { word: "booking", meaning: "ì˜ˆì•½", type: "ëª…ì‚¬" },
            { word: "culture", meaning: "ë¬¸í™”", type: "ëª…ì‚¬" },
            { word: "destination", meaning: "ëª©ì ì§€", type: "ëª…ì‚¬" },
            { word: "explore", meaning: "íƒí—˜í•˜ë‹¤", type: "ë™ì‚¬" },
            { word: "flight", meaning: "ë¹„í–‰í¸", type: "ëª…ì‚¬" },
            { word: "guide", meaning: "ê°€ì´ë“œ", type: "ëª…ì‚¬" },
            { word: "hotel", meaning: "í˜¸í…”", type: "ëª…ì‚¬" },
            { word: "itinerary", meaning: "ì¼ì •í‘œ", type: "ëª…ì‚¬" },
            { word: "journey", meaning: "ì—¬í–‰", type: "ëª…ì‚¬" },
            { word: "luggage", meaning: "ì§", type: "ëª…ì‚¬" },
            { word: "passport", meaning: "ì—¬ê¶Œ", type: "ëª…ì‚¬" },
            { word: "reservation", meaning: "ì˜ˆì•½", type: "ëª…ì‚¬" },
            { word: "sightseeing", meaning: "ê´€ê´‘", type: "ëª…ì‚¬" },
            { word: "ticket", meaning: "í‹°ì¼“", type: "ëª…ì‚¬" },
            { word: "tourist", meaning: "ê´€ê´‘ê°", type: "ëª…ì‚¬" },
            { word: "transportation", meaning: "êµí†µ", type: "ëª…ì‚¬" },
            { word: "vacation", meaning: "íœ´ê°€", type: "ëª…ì‚¬" },
            { word: "backpack", meaning: "ë°°ë‚­", type: "ëª…ì‚¬" },
            { word: "border", meaning: "êµ­ê²½", type: "ëª…ì‚¬" },
            { word: "currency", meaning: "í™”í", type: "ëª…ì‚¬" },
            { word: "departure", meaning: "ì¶œë°œ", type: "ëª…ì‚¬" },
            { word: "embassy", meaning: "ëŒ€ì‚¬ê´€", type: "ëª…ì‚¬" },
            { word: "festival", meaning: "ì¶•ì œ", type: "ëª…ì‚¬" },
            { word: "geography", meaning: "ì§€ë¦¬", type: "ëª…ì‚¬" },
            { word: "highway", meaning: "ê³ ì†ë„ë¡œ", type: "ëª…ì‚¬" },
            { word: "immigration", meaning: "ì¶œì…êµ­", type: "ëª…ì‚¬" },
            { word: "jet lag", meaning: "ì‹œì°¨ë³‘", type: "ëª…ì‚¬" },
            { word: "landmark", meaning: "ëœë“œë§ˆí¬", type: "ëª…ì‚¬" },
            { word: "metro", meaning: "ì§€í•˜ì² ", type: "ëª…ì‚¬" },
            { word: "navigation", meaning: "ë‚´ë¹„ê²Œì´ì…˜", type: "ëª…ì‚¬" },
            { word: "overseas", meaning: "í•´ì™¸ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "pilgrimage", meaning: "ìˆœë¡€", type: "ëª…ì‚¬" },
            { word: "railway", meaning: "ì² ë„", type: "ëª…ì‚¬" },
            { word: "souvenir", meaning: "ê¸°ë…í’ˆ", type: "ëª…ì‚¬" },
            { word: "terminal", meaning: "í„°ë¯¸ë„", type: "ëª…ì‚¬" },
            { word: "visa", meaning: "ë¹„ì", type: "ëª…ì‚¬" },
            { word: "voyage", meaning: "í•­í•´", type: "ëª…ì‚¬" }
        ]
    },
    daily: {
        name: "ì¼ìƒ ìƒí™œ",
        icon: "ğŸ ",
        words: [
            { word: "breakfast", meaning: "ì•„ì¹¨ì‹ì‚¬", type: "ëª…ì‚¬" },
            { word: "celebrate", meaning: "ì¶•í•˜í•˜ë‹¤", type: "ë™ì‚¬" },
            { word: "comfortable", meaning: "í¸ì•ˆí•œ", type: "í˜•ìš©ì‚¬" },
            { word: "dinner", meaning: "ì €ë…ì‹ì‚¬", type: "ëª…ì‚¬" },
            { word: "exercise", meaning: "ìš´ë™", type: "ëª…ì‚¬" },
            { word: "family", meaning: "ê°€ì¡±", type: "ëª…ì‚¬" },
            { word: "grocery", meaning: "ì‹ë£Œí’ˆ", type: "ëª…ì‚¬" },
            { word: "healthy", meaning: "ê±´ê°•í•œ", type: "í˜•ìš©ì‚¬" },
            { word: "kitchen", meaning: "ì£¼ë°©", type: "ëª…ì‚¬" },
            { word: "laundry", meaning: "ì„¸íƒ", type: "ëª…ì‚¬" },
            { word: "medicine", meaning: "ì•½", type: "ëª…ì‚¬" },
            { word: "neighbor", meaning: "ì´ì›ƒ", type: "ëª…ì‚¬" },
            { word: "outdoors", meaning: "ì•¼ì™¸", type: "ë¶€ì‚¬" },
            { word: "pet", meaning: "ì• ì™„ë™ë¬¼", type: "ëª…ì‚¬" },
            { word: "recipe", meaning: "ìš”ë¦¬ë²•", type: "ëª…ì‚¬" },
            { word: "shopping", meaning: "ì‡¼í•‘", type: "ëª…ì‚¬" },
            { word: "television", meaning: "í…”ë ˆë¹„ì „", type: "ëª…ì‚¬" },
            { word: "umbrella", meaning: "ìš°ì‚°", type: "ëª…ì‚¬" },
            { word: "vegetable", meaning: "ì•¼ì±„", type: "ëª…ì‚¬" },
            { word: "weekend", meaning: "ì£¼ë§", type: "ëª…ì‚¬" },
            { word: "appointment", meaning: "ì•½ì†", type: "ëª…ì‚¬" },
            { word: "budget", meaning: "ì˜ˆì‚°", type: "ëª…ì‚¬" },
            { word: "commute", meaning: "í†µê·¼í•˜ë‹¤", type: "ë™ì‚¬" },
            { word: "dentist", meaning: "ì¹˜ê³¼ì˜ì‚¬", type: "ëª…ì‚¬" },
            { word: "emergency", meaning: "ì‘ê¸‰ìƒí™©", type: "ëª…ì‚¬" },
            { word: "furniture", meaning: "ê°€êµ¬", type: "ëª…ì‚¬" },
            { word: "garbage", meaning: "ì“°ë ˆê¸°", type: "ëª…ì‚¬" },
            { word: "hobby", meaning: "ì·¨ë¯¸", type: "ëª…ì‚¬" },
            { word: "insurance", meaning: "ë³´í—˜", type: "ëª…ì‚¬" },
            { word: "journal", meaning: "ì¼ê¸°", type: "ëª…ì‚¬" },
            { word: "kindergarten", meaning: "ìœ ì¹˜ì›", type: "ëª…ì‚¬" },
            { word: "lifestyle", meaning: "ìƒí™œë°©ì‹", type: "ëª…ì‚¬" },
            { word: "maintenance", meaning: "ìœ ì§€ë³´ìˆ˜", type: "ëª…ì‚¬" },
            { word: "nutrition", meaning: "ì˜ì–‘", type: "ëª…ì‚¬" },
            { word: "organization", meaning: "ì •ë¦¬", type: "ëª…ì‚¬" },
            { word: "pharmacy", meaning: "ì•½êµ­", type: "ëª…ì‚¬" },
            { word: "routine", meaning: "ì¼ìƒ", type: "ëª…ì‚¬" },
            { word: "schedule", meaning: "ì¼ì •", type: "ëª…ì‚¬" },
            { word: "tradition", meaning: "ì „í†µ", type: "ëª…ì‚¬" },
            { word: "utility", meaning: "ê³µê³µìš”ê¸ˆ", type: "ëª…ì‚¬" }
        ]
    },
    academic: {
        name: "í•™ë¬¸ & êµìœ¡",
        icon: "ğŸ“š",
        words: [
            { word: "academic", meaning: "í•™ë¬¸ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "analysis", meaning: "ë¶„ì„", type: "ëª…ì‚¬" },
            { word: "assignment", meaning: "ê³¼ì œ", type: "ëª…ì‚¬" },
            { word: "calculate", meaning: "ê³„ì‚°í•˜ë‹¤", type: "ë™ì‚¬" },
            { word: "curriculum", meaning: "êµìœ¡ê³¼ì •", type: "ëª…ì‚¬" },
            { word: "debate", meaning: "í† ë¡ ", type: "ëª…ì‚¬" },
            { word: "education", meaning: "êµìœ¡", type: "ëª…ì‚¬" },
            { word: "examination", meaning: "ì‹œí—˜", type: "ëª…ì‚¬" },
            { word: "graduate", meaning: "ì¡¸ì—…ìƒ", type: "ëª…ì‚¬" },
            { word: "knowledge", meaning: "ì§€ì‹", type: "ëª…ì‚¬" },
            { word: "lecture", meaning: "ê°•ì˜", type: "ëª…ì‚¬" },
            { word: "library", meaning: "ë„ì„œê´€", type: "ëª…ì‚¬" },
            { word: "mathematics", meaning: "ìˆ˜í•™", type: "ëª…ì‚¬" },
            { word: "professor", meaning: "êµìˆ˜", type: "ëª…ì‚¬" },
            { word: "scholarship", meaning: "ì¥í•™ê¸ˆ", type: "ëª…ì‚¬" },
            { word: "semester", meaning: "í•™ê¸°", type: "ëª…ì‚¬" },
            { word: "student", meaning: "í•™ìƒ", type: "ëª…ì‚¬" },
            { word: "textbook", meaning: "êµê³¼ì„œ", type: "ëª…ì‚¬" },
            { word: "university", meaning: "ëŒ€í•™êµ", type: "ëª…ì‚¬" },
            { word: "vocabulary", meaning: "ì–´íœ˜", type: "ëª…ì‚¬" },
            { word: "bibliography", meaning: "ì°¸ê³ ë¬¸í—Œ", type: "ëª…ì‚¬" },
            { word: "certificate", meaning: "ì¦ëª…ì„œ", type: "ëª…ì‚¬" },
            { word: "discipline", meaning: "í•™ë¬¸ë¶„ì•¼", type: "ëª…ì‚¬" },
            { word: "essay", meaning: "ì—ì„¸ì´", type: "ëª…ì‚¬" },
            { word: "faculty", meaning: "êµìˆ˜ì§„", type: "ëª…ì‚¬" },
            { word: "grammar", meaning: "ë¬¸ë²•", type: "ëª…ì‚¬" },
            { word: "hypothesis", meaning: "ê°€ì„¤", type: "ëª…ì‚¬" },
            { word: "internship", meaning: "ì¸í„´ì‹­", type: "ëª…ì‚¬" },
            { word: "journal", meaning: "í•™ìˆ ì§€", type: "ëª…ì‚¬" },
            { word: "kindergarten", meaning: "ìœ ì¹˜ì›", type: "ëª…ì‚¬" },
            { word: "laboratory", meaning: "ì‹¤í—˜ì‹¤", type: "ëª…ì‚¬" },
            { word: "methodology", meaning: "ë°©ë²•ë¡ ", type: "ëª…ì‚¬" },
            { word: "notation", meaning: "í‘œê¸°ë²•", type: "ëª…ì‚¬" },
            { word: "outline", meaning: "ê°œìš”", type: "ëª…ì‚¬" },
            { word: "plagiarism", meaning: "í‘œì ˆ", type: "ëª…ì‚¬" },
            { word: "qualification", meaning: "ìê²©", type: "ëª…ì‚¬" },
            { word: "research", meaning: "ì—°êµ¬", type: "ëª…ì‚¬" },
            { word: "statistics", meaning: "í†µê³„í•™", type: "ëª…ì‚¬" },
            { word: "thesis", meaning: "ë…¼ë¬¸", type: "ëª…ì‚¬" },
            { word: "undergraduate", meaning: "í•™ë¶€ìƒ", type: "ëª…ì‚¬" }
        ]
    },
    technology: {
        name: "IT & ì»´í“¨í„°",
        icon: "ğŸ’»",
        words: [
            { word: "algorithm", meaning: "ì•Œê³ ë¦¬ì¦˜", type: "ëª…ì‚¬" },
            { word: "application", meaning: "ì• í”Œë¦¬ì¼€ì´ì…˜", type: "ëª…ì‚¬" },
            { word: "backup", meaning: "ë°±ì—…", type: "ëª…ì‚¬" },
            { word: "browser", meaning: "ë¸Œë¼ìš°ì €", type: "ëª…ì‚¬" },
            { word: "cloud", meaning: "í´ë¼ìš°ë“œ", type: "ëª…ì‚¬" },
            { word: "database", meaning: "ë°ì´í„°ë² ì´ìŠ¤", type: "ëª…ì‚¬" },
            { word: "download", meaning: "ë‹¤ìš´ë¡œë“œ", type: "ë™ì‚¬" },
            { word: "encryption", meaning: "ì•”í˜¸í™”", type: "ëª…ì‚¬" },
            { word: "firewall", meaning: "ë°©í™”ë²½", type: "ëª…ì‚¬" },
            { word: "graphics", meaning: "ê·¸ë˜í”½", type: "ëª…ì‚¬" },
            { word: "hardware", meaning: "í•˜ë“œì›¨ì–´", type: "ëª…ì‚¬" },
            { word: "interface", meaning: "ì¸í„°í˜ì´ìŠ¤", type: "ëª…ì‚¬" },
            { word: "javascript", meaning: "ìë°”ìŠ¤í¬ë¦½íŠ¸", type: "ëª…ì‚¬" },
            { word: "keyboard", meaning: "í‚¤ë³´ë“œ", type: "ëª…ì‚¬" },
            { word: "laptop", meaning: "ë…¸íŠ¸ë¶", type: "ëª…ì‚¬" },
            { word: "monitor", meaning: "ëª¨ë‹ˆí„°", type: "ëª…ì‚¬" },
            { word: "network", meaning: "ë„¤íŠ¸ì›Œí¬", type: "ëª…ì‚¬" },
            { word: "operating", meaning: "ìš´ì˜í•˜ëŠ”", type: "í˜•ìš©ì‚¬" },
            { word: "password", meaning: "ë¹„ë°€ë²ˆí˜¸", type: "ëª…ì‚¬" },
            { word: "processor", meaning: "í”„ë¡œì„¸ì„œ", type: "ëª…ì‚¬" },
            { word: "programming", meaning: "í”„ë¡œê·¸ë˜ë°", type: "ëª…ì‚¬" },
            { word: "router", meaning: "ë¼ìš°í„°", type: "ëª…ì‚¬" },
            { word: "server", meaning: "ì„œë²„", type: "ëª…ì‚¬" },
            { word: "software", meaning: "ì†Œí”„íŠ¸ì›¨ì–´", type: "ëª…ì‚¬" },
            { word: "storage", meaning: "ì €ì¥ì†Œ", type: "ëª…ì‚¬" },
            { word: "update", meaning: "ì—…ë°ì´íŠ¸", type: "ë™ì‚¬" },
            { word: "virus", meaning: "ë°”ì´ëŸ¬ìŠ¤", type: "ëª…ì‚¬" },
            { word: "website", meaning: "ì›¹ì‚¬ì´íŠ¸", type: "ëª…ì‚¬" },
            { word: "wireless", meaning: "ë¬´ì„ ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "smartphone", meaning: "ìŠ¤ë§ˆíŠ¸í°", type: "ëª…ì‚¬" },
            { word: "artificial", meaning: "ì¸ê³µì˜", type: "í˜•ìš©ì‚¬" },
            { word: "intelligence", meaning: "ì§€ëŠ¥", type: "ëª…ì‚¬" },
            { word: "machine", meaning: "ê¸°ê³„", type: "ëª…ì‚¬" },
            { word: "learning", meaning: "í•™ìŠµ", type: "ëª…ì‚¬" },
            { word: "virtual", meaning: "ê°€ìƒì˜", type: "í˜•ìš©ì‚¬" },
            { word: "reality", meaning: "í˜„ì‹¤", type: "ëª…ì‚¬" },
            { word: "blockchain", meaning: "ë¸”ë¡ì²´ì¸", type: "ëª…ì‚¬" },
            { word: "cryptocurrency", meaning: "ì•”í˜¸í™”í", type: "ëª…ì‚¬" },
            { word: "cybersecurity", meaning: "ì‚¬ì´ë²„ë³´ì•ˆ", type: "ëª…ì‚¬" },
            { word: "automation", meaning: "ìë™í™”", type: "ëª…ì‚¬" }
        ]
    },
    medical: {
        name: "ì˜ë£Œ ê±´ê°•",
        icon: "ğŸ¥",
        words: [
            { word: "anatomy", meaning: "í•´ë¶€í•™", type: "ëª…ì‚¬" },
            { word: "antibiotic", meaning: "í•­ìƒì œ", type: "ëª…ì‚¬" },
            { word: "appointment", meaning: "ì˜ˆì•½", type: "ëª…ì‚¬" },
            { word: "diagnosis", meaning: "ì§„ë‹¨", type: "ëª…ì‚¬" },
            { word: "emergency", meaning: "ì‘ê¸‰ìƒí™©", type: "ëª…ì‚¬" },
            { word: "examination", meaning: "ê²€ì‚¬", type: "ëª…ì‚¬" },
            { word: "fever", meaning: "ì—´", type: "ëª…ì‚¬" },
            { word: "hospital", meaning: "ë³‘ì›", type: "ëª…ì‚¬" },
            { word: "injection", meaning: "ì£¼ì‚¬", type: "ëª…ì‚¬" },
            { word: "medicine", meaning: "ì•½", type: "ëª…ì‚¬" },
            { word: "nurse", meaning: "ê°„í˜¸ì‚¬", type: "ëª…ì‚¬" },
            { word: "operation", meaning: "ìˆ˜ìˆ ", type: "ëª…ì‚¬" },
            { word: "patient", meaning: "í™˜ì", type: "ëª…ì‚¬" },
            { word: "prescription", meaning: "ì²˜ë°©ì „", type: "ëª…ì‚¬" },
            { word: "recovery", meaning: "íšŒë³µ", type: "ëª…ì‚¬" },
            { word: "surgeon", meaning: "ì™¸ê³¼ì˜ì‚¬", type: "ëª…ì‚¬" },
            { word: "symptom", meaning: "ì¦ìƒ", type: "ëª…ì‚¬" },
            { word: "therapy", meaning: "ì¹˜ë£Œ", type: "ëª…ì‚¬" },
            { word: "treatment", meaning: "ì¹˜ë£Œ", type: "ëª…ì‚¬" },
            { word: "vaccine", meaning: "ë°±ì‹ ", type: "ëª…ì‚¬" },
            { word: "allergy", meaning: "ì•Œë ˆë¥´ê¸°", type: "ëª…ì‚¬" },
            { word: "bandage", meaning: "ë¶•ëŒ€", type: "ëª…ì‚¬" },
            { word: "cardiac", meaning: "ì‹¬ì¥ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "diabetes", meaning: "ë‹¹ë‡¨ë³‘", type: "ëª…ì‚¬" },
            { word: "epidemic", meaning: "ìœ í–‰ë³‘", type: "ëª…ì‚¬" },
            { word: "fracture", meaning: "ê³¨ì ˆ", type: "ëª…ì‚¬" },
            { word: "genetic", meaning: "ìœ ì „ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "hygiene", meaning: "ìœ„ìƒ", type: "ëª…ì‚¬" },
            { word: "immune", meaning: "ë©´ì—­ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "laboratory", meaning: "ì‹¤í—˜ì‹¤", type: "ëª…ì‚¬" },
            { word: "mental", meaning: "ì •ì‹ ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "nutrition", meaning: "ì˜ì–‘", type: "ëª…ì‚¬" },
            { word: "obesity", meaning: "ë¹„ë§Œ", type: "ëª…ì‚¬" },
            { word: "physical", meaning: "ì‹ ì²´ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "quarantine", meaning: "ê²©ë¦¬", type: "ëª…ì‚¬" },
            { word: "radiation", meaning: "ë°©ì‚¬ì„ ", type: "ëª…ì‚¬" },
            { word: "specialist", meaning: "ì „ë¬¸ì˜", type: "ëª…ì‚¬" },
            { word: "trauma", meaning: "ì™¸ìƒ", type: "ëª…ì‚¬" },
            { word: "ultrasound", meaning: "ì´ˆìŒíŒŒ", type: "ëª…ì‚¬" },
            { word: "vitamin", meaning: "ë¹„íƒ€ë¯¼", type: "ëª…ì‚¬" }
        ]
    },
    legal: {
        name: "ë²•ë¥  ë²•ë¬´",
        icon: "âš–ï¸",
        words: [
            { word: "attorney", meaning: "ë³€í˜¸ì‚¬", type: "ëª…ì‚¬" },
            { word: "court", meaning: "ë²•ì›", type: "ëª…ì‚¬" },
            { word: "contract", meaning: "ê³„ì•½", type: "ëª…ì‚¬" },
            { word: "defendant", meaning: "í”¼ê³ ", type: "ëª…ì‚¬" },
            { word: "evidence", meaning: "ì¦ê±°", type: "ëª…ì‚¬" },
            { word: "guilty", meaning: "ìœ ì£„ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "innocent", meaning: "ë¬´ì£„ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "judge", meaning: "íŒì‚¬", type: "ëª…ì‚¬" },
            { word: "jury", meaning: "ë°°ì‹¬ì›", type: "ëª…ì‚¬" },
            { word: "lawsuit", meaning: "ì†Œì†¡", type: "ëª…ì‚¬" },
            { word: "legal", meaning: "ë²•ì ì¸", type: "í˜•ìš©ì‚¬" },
            { word: "license", meaning: "ë©´í—ˆ", type: "ëª…ì‚¬" },
            { word: "plaintiff", meaning: "ì›ê³ ", type: "ëª…ì‚¬" },
            { word: "prosecution", meaning: "ê¸°ì†Œ", type: "ëª…ì‚¬" },
            { word: "regulation", meaning: "ê·œì •", type: "ëª…ì‚¬" },
            { word: "statute", meaning: "ë²•ë ¹", type: "ëª…ì‚¬" },
            { word: "testimony", meaning: "ì¦ì–¸", type: "ëª…ì‚¬" },
            { word: "trial", meaning: "ì¬íŒ", type: "ëª…ì‚¬" },
            { word: "verdict", meaning: "í‰ê²°", type: "ëª…ì‚¬" },
            { word: "witness", meaning: "ì¦ì¸", type: "ëª…ì‚¬" },
            { word: "appeal", meaning: "í•­ì†Œ", type: "ëª…ì‚¬" },
            { word: "bail", meaning: "ë³´ì„", type: "ëª…ì‚¬" },
            { word: "copyright", meaning: "ì €ì‘ê¶Œ", type: "ëª…ì‚¬" },
            { word: "custody", meaning: "êµ¬ê¸ˆ", type: "ëª…ì‚¬" },
            { word: "enforcement", meaning: "ì§‘í–‰", type: "ëª…ì‚¬" },
            { word: "felony", meaning: "ì¤‘ì£„", type: "ëª…ì‚¬" },
            { word: "guardian", meaning: "í›„ê²¬ì¸", type: "ëª…ì‚¬" },
            { word: "hearing", meaning: "ì²­ë¬¸íšŒ", type: "ëª…ì‚¬" },
            { word: "inheritance", meaning: "ìƒì†", type: "ëª…ì‚¬" },
            { word: "jurisdiction", meaning: "ê´€í• ê¶Œ", type: "ëª…ì‚¬" },
            { word: "liability", meaning: "ì±…ì„", type: "ëª…ì‚¬" },
            { word: "misdemeanor", meaning: "ê²½ë²”ì£„", type: "ëª…ì‚¬" },
            { word: "notary", meaning: "ê³µì¦ì¸", type: "ëª…ì‚¬" },
            { word: "oath", meaning: "ë§¹ì„¸", type: "ëª…ì‚¬" },
            { word: "petition", meaning: "íƒ„ì›ì„œ", type: "ëª…ì‚¬" },
            { word: "settlement", meaning: "í•©ì˜", type: "ëª…ì‚¬" },
            { word: "subpoena", meaning: "ì†Œí™˜ì¥", type: "ëª…ì‚¬" },
            { word: "trademark", meaning: "ìƒí‘œ", type: "ëª…ì‚¬" },
            { word: "violation", meaning: "ìœ„ë°˜", type: "ëª…ì‚¬" },
            { word: "warrant", meaning: "ì˜ì¥", type: "ëª…ì‚¬" }
        ]
    },
    cooking: {
        name: "ìš”ë¦¬ ìŒì‹",
        icon: "ğŸ³",
        words: [
            { word: "bake", meaning: "êµ½ë‹¤", type: "ë™ì‚¬" },
            { word: "boil", meaning: "ë“ì´ë‹¤", type: "ë™ì‚¬" },
            { word: "chop", meaning: "ì°ë‹¤", type: "ë™ì‚¬" },
            { word: "dice", meaning: "ê¹ë‘‘ì°ê¸°í•˜ë‹¤", type: "ë™ì‚¬" },
            { word: "fry", meaning: "íŠ€ê¸°ë‹¤", type: "ë™ì‚¬" },
            { word: "grill", meaning: "êµ½ë‹¤", type: "ë™ì‚¬" },
            { word: "marinate", meaning: "ì¬ìš°ë‹¤", type: "ë™ì‚¬" },
            { word: "mince", meaning: "ë‹¤ì§€ë‹¤", type: "ë™ì‚¬" },
            { word: "roast", meaning: "êµ¬ì›Œë‚´ë‹¤", type: "ë™ì‚¬" },
            { word: "sautÃ©", meaning: "ë³¶ë‹¤", type: "ë™ì‚¬" },
            { word: "simmer", meaning: "ì•½í•˜ê²Œ ë“ì´ë‹¤", type: "ë™ì‚¬" },
            { word: "steam", meaning: "ì°Œë‹¤", type: "ë™ì‚¬" },
            { word: "stir", meaning: "ì “ë‹¤", type: "ë™ì‚¬" },
            { word: "whisk", meaning: "íœ˜ì “ë‹¤", type: "ë™ì‚¬" },
            { word: "blend", meaning: "ì„ë‹¤", type: "ë™ì‚¬" },
            { word: "ingredient", meaning: "ì¬ë£Œ", type: "ëª…ì‚¬" },
            { word: "recipe", meaning: "ì¡°ë¦¬ë²•", type: "ëª…ì‚¬" },
            { word: "seasoning", meaning: "ì–‘ë…", type: "ëª…ì‚¬" },
            { word: "spice", meaning: "í–¥ì‹ ë£Œ", type: "ëª…ì‚¬" },
            { word: "flavor", meaning: "ë§›", type: "ëª…ì‚¬" },
            { word: "appetizer", meaning: "ì „ì±„ìš”ë¦¬", type: "ëª…ì‚¬" },
            { word: "dessert", meaning: "ë””ì €íŠ¸", type: "ëª…ì‚¬" },
            { word: "cuisine", meaning: "ìš”ë¦¬", type: "ëª…ì‚¬" },
            { word: "garnish", meaning: "ê³ ëª…", type: "ëª…ì‚¬" },
            { word: "portion", meaning: "ë¶„ëŸ‰", type: "ëª…ì‚¬" },
            { word: "texture", meaning: "ì‹ê°", type: "ëª…ì‚¬" },
            { word: "aroma", meaning: "í–¥", type: "ëª…ì‚¬" },
            { word: "crispy", meaning: "ë°”ì‚­í•œ", type: "í˜•ìš©ì‚¬" },
            { word: "tender", meaning: "ë¶€ë“œëŸ¬ìš´", type: "í˜•ìš©ì‚¬" },
            { word: "spicy", meaning: "ë§¤ìš´", type: "í˜•ìš©ì‚¬" },
            { word: "sweet", meaning: "ë‹¨", type: "í˜•ìš©ì‚¬" },
            { word: "sour", meaning: "ì‹ ", type: "í˜•ìš©ì‚¬" },
            { word: "bitter", meaning: "ì“´", type: "í˜•ìš©ì‚¬" },
            { word: "salty", meaning: "ì§ ", type: "í˜•ìš©ì‚¬" },
            { word: "fresh", meaning: "ì‹ ì„ í•œ", type: "í˜•ìš©ì‚¬" },
            { word: "organic", meaning: "ìœ ê¸°ë†ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "processed", meaning: "ê°€ê³µëœ", type: "í˜•ìš©ì‚¬" },
            { word: "homemade", meaning: "ì§‘ì—ì„œ ë§Œë“ ", type: "í˜•ìš©ì‚¬" },
            { word: "nutritious", meaning: "ì˜ì–‘ê°€ ìˆëŠ”", type: "í˜•ìš©ì‚¬" },
            { word: "delicious", meaning: "ë§›ìˆëŠ”", type: "í˜•ìš©ì‚¬" }
        ]
    },
    sports: {
        name: "ìŠ¤í¬ì¸  ìš´ë™",
        icon: "âš½",
        words: [
            { word: "athlete", meaning: "ìš´ë™ì„ ìˆ˜", type: "ëª…ì‚¬" },
            { word: "coach", meaning: "ì½”ì¹˜", type: "ëª…ì‚¬" },
            { word: "team", meaning: "íŒ€", type: "ëª…ì‚¬" },
            { word: "match", meaning: "ê²½ê¸°", type: "ëª…ì‚¬" },
            { word: "tournament", meaning: "í† ë„ˆë¨¼íŠ¸", type: "ëª…ì‚¬" },
            { word: "championship", meaning: "ì„ ìˆ˜ê¶ŒëŒ€íšŒ", type: "ëª…ì‚¬" },
            { word: "victory", meaning: "ìŠ¹ë¦¬", type: "ëª…ì‚¬" },
            { word: "defeat", meaning: "íŒ¨ë°°", type: "ëª…ì‚¬" },
            { word: "score", meaning: "ì ìˆ˜", type: "ëª…ì‚¬" },
            { word: "goal", meaning: "ê³¨", type: "ëª…ì‚¬" },
            { word: "referee", meaning: "ì‹¬íŒ", type: "ëª…ì‚¬" },
            { word: "stadium", meaning: "ê²½ê¸°ì¥", type: "ëª…ì‚¬" },
            { word: "training", meaning: "í›ˆë ¨", type: "ëª…ì‚¬" },
            { word: "exercise", meaning: "ìš´ë™", type: "ëª…ì‚¬" },
            { word: "fitness", meaning: "ì²´ë ¥", type: "ëª…ì‚¬" },
            { word: "competition", meaning: "ê²½ìŸ", type: "ëª…ì‚¬" },
            { word: "opponent", meaning: "ìƒëŒ€", type: "ëª…ì‚¬" },
            { word: "strategy", meaning: "ì „ëµ", type: "ëª…ì‚¬" },
            { word: "technique", meaning: "ê¸°ìˆ ", type: "ëª…ì‚¬" },
            { word: "performance", meaning: "ì„±ê³¼", type: "ëª…ì‚¬" },
            { word: "medal", meaning: "ë©”ë‹¬", type: "ëª…ì‚¬" },
            { word: "record", meaning: "ê¸°ë¡", type: "ëª…ì‚¬" },
            { word: "equipment", meaning: "ì¥ë¹„", type: "ëª…ì‚¬" },
            { word: "uniform", meaning: "ìœ ë‹ˆí¼", type: "ëª…ì‚¬" },
            { word: "captain", meaning: "ì£¼ì¥", type: "ëª…ì‚¬" },
            { word: "substitute", meaning: "êµì²´ì„ ìˆ˜", type: "ëª…ì‚¬" },
            { word: "penalty", meaning: "í˜ë„í‹°", type: "ëª…ì‚¬" },
            { word: "foul", meaning: "ë°˜ì¹™", type: "ëª…ì‚¬" },
            { word: "offside", meaning: "ì˜¤í”„ì‚¬ì´ë“œ", type: "ëª…ì‚¬" },
            { word: "timeout", meaning: "íƒ€ì„ì•„ì›ƒ", type: "ëª…ì‚¬" },
            { word: "sprint", meaning: "ë‹¨ê±°ë¦¬ ë‹¬ë¦¬ê¸°", type: "ëª…ì‚¬" },
            { word: "marathon", meaning: "ë§ˆë¼í†¤", type: "ëª…ì‚¬" },
            { word: "endurance", meaning: "ì§€êµ¬ë ¥", type: "ëª…ì‚¬" },
            { word: "strength", meaning: "í˜", type: "ëª…ì‚¬" },
            { word: "agility", meaning: "ë¯¼ì²©ì„±", type: "ëª…ì‚¬" },
            { word: "flexibility", meaning: "ìœ ì—°ì„±", type: "ëª…ì‚¬" },
            { word: "coordination", meaning: "ì¡°ì •ë ¥", type: "ëª…ì‚¬" },
            { word: "balance", meaning: "ê· í˜•", type: "ëª…ì‚¬" },
            { word: "professional", meaning: "í”„ë¡œì˜", type: "í˜•ìš©ì‚¬" },
            { word: "amateur", meaning: "ì•„ë§ˆì¶”ì–´ì˜", type: "í˜•ìš©ì‚¬" }
        ]
    }
};

class VocabularyQuiz {
    constructor() {
        this.currentTheme = null;
        this.currentWordIndex = 0;
        this.totalQuestions = 0;
        this.correctAnswers = 0;
        this.usedIndices = [];
        this.currentChoices = [];
        this.correctChoiceIndex = 0;
        this.selectedChoice = null;
        this.autoAdvanceEnabled = false;
        this.autoAdvanceTimeout = null;
        this.typingMode = false;
        
        // Challenge mode properties
        this.challengeMode = false;
        this.currentChallenge = null;
        
        // Review mode properties
        this.reviewMode = false;
        this.reviewWords = [];
        
        // Progress tracking
        this.userProgress = this.loadUserProgress();
        this.sessionStats = {
            wordsLearned: 0,
            correctAnswers: 0,
            totalAnswers: 0,
            startTime: Date.now(),
            questionStartTime: null,
            actualStudyTime: 0
        };
        
        // Speech synthesis for pronunciation
        this.speechSynthesis = window.speechSynthesis;
        this.voice = null;
        this.initVoice();
        
        this.initElements();
        this.bindEvents();
        
        // Initialize leaderboard manager
        this.initializeLeaderboard();
        
        // ì±Œë¦°ì§€ ëª¨ë“œ í™•ì¸
        this.checkChallengeMode() || this.showThemeSelector();
    }
    
    // Progress Management Methods
    loadUserProgress() {
        try {
            const saved = localStorage.getItem('vocabularyQuizProgress');
            const progress = saved ? JSON.parse(saved) : {
                completedThemes: {},
                totalWordsLearned: 0,
                bestScores: {},
                learningStreak: 0,
                lastPlayDate: null,
                wrongAnswers: {},
                totalSessionTime: 0,
                learnedWords: [],
                actualStudyTime: 0
            };
            
            // Ensure new properties exist for backward compatibility
            if (!progress.learnedWords) progress.learnedWords = [];
            if (typeof progress.actualStudyTime === 'undefined') progress.actualStudyTime = 0;
            if (!progress.completedThemes) progress.completedThemes = {};
            if (!progress.bestScores) progress.bestScores = {};
            if (!progress.wrongAnswers) progress.wrongAnswers = {};
            
            return progress;
        } catch (error) {
            console.warn('Could not load user progress:', error);
            return {
                completedThemes: {},
                totalWordsLearned: 0,
                bestScores: {},
                learningStreak: 0,
                lastPlayDate: null,
                wrongAnswers: {},
                totalSessionTime: 0,
                learnedWords: [],
                actualStudyTime: 0
            };
        }
    }
    
    saveUserProgress() {
        try {
            localStorage.setItem('vocabularyQuizProgress', JSON.stringify(this.userProgress));
        } catch (error) {
            console.warn('Could not save user progress:', error);
        }
    }
    
    updateProgress(themeKey, score, accuracy) {
        const today = new Date().toDateString();
        
        // Update theme completion
        if (!this.userProgress.completedThemes[themeKey]) {
            this.userProgress.completedThemes[themeKey] = {
                timesCompleted: 0,
                bestScore: 0,
                lastCompleted: null,
                totalAttempts: 0
            };
        }
        
        const themeProgress = this.userProgress.completedThemes[themeKey];
        themeProgress.timesCompleted++;
        themeProgress.totalAttempts++;
        themeProgress.lastCompleted = today;
        themeProgress.bestScore = Math.max(themeProgress.bestScore, score);
        
        // Update best scores
        this.userProgress.bestScores[themeKey] = Math.max(
            this.userProgress.bestScores[themeKey] || 0,
            score
        );
        
        // Update learning streak
        if (this.userProgress.lastPlayDate !== today) {
            if (this.userProgress.lastPlayDate === new Date(Date.now() - 86400000).toDateString()) {
                this.userProgress.learningStreak++;
            } else {
                this.userProgress.learningStreak = 1;
            }
            this.userProgress.lastPlayDate = today;
        }
        
        // Update session stats with accurate study time
        this.userProgress.actualStudyTime += this.sessionStats.actualStudyTime;
        
        // Track unique words learned in this theme
        const themeWords = vocabularyThemes[themeKey].words;
        for (const word of themeWords) {
            const wordKey = `${themeKey}_${word.word}`;
            if (!this.userProgress.learnedWords.includes(wordKey)) {
                this.userProgress.learnedWords.push(wordKey);
            }
        }
        
        // Update total words learned (accurate count)
        this.userProgress.totalWordsLearned = this.userProgress.learnedWords.length;
        
        this.saveUserProgress();
    }
    
    trackWrongAnswer() {
        const currentWord = vocabularyThemes[this.currentTheme].words[this.currentWordIndex];
        const wrongAnswerKey = `${this.currentTheme}_${this.currentWordIndex}`;
        
        if (!this.userProgress.wrongAnswers[this.currentTheme]) {
            this.userProgress.wrongAnswers[this.currentTheme] = {};
        }
        
        if (!this.userProgress.wrongAnswers[this.currentTheme][wrongAnswerKey]) {
            this.userProgress.wrongAnswers[this.currentTheme][wrongAnswerKey] = {
                word: currentWord.word,
                meaning: currentWord.meaning,
                type: currentWord.type,
                wrongCount: 0,
                lastWrong: null
            };
        }
        
        this.userProgress.wrongAnswers[this.currentTheme][wrongAnswerKey].wrongCount++;
        this.userProgress.wrongAnswers[this.currentTheme][wrongAnswerKey].lastWrong = new Date().toISOString();
        
        this.saveUserProgress();
    }
    
    getWrongAnswersForReview(themeKey = null) {
        const wrongAnswers = [];
        
        if (themeKey) {
            // Get wrong answers for specific theme
            const themeWrong = this.userProgress.wrongAnswers[themeKey] || {};
            Object.values(themeWrong).forEach(item => {
                wrongAnswers.push({
                    ...item,
                    theme: themeKey
                });
            });
        } else {
            // Get all wrong answers
            Object.keys(this.userProgress.wrongAnswers).forEach(theme => {
                const themeWrong = this.userProgress.wrongAnswers[theme] || {};
                Object.values(themeWrong).forEach(item => {
                    wrongAnswers.push({
                        ...item,
                        theme: theme
                    });
                });
            });
        }
        
        // Sort by most recent first
        return wrongAnswers.sort((a, b) => new Date(b.lastWrong) - new Date(a.lastWrong));
    }
    
    startReview(themeKey) {
        const wrongAnswers = this.getWrongAnswersForReview(themeKey);
        
        if (wrongAnswers.length === 0) {
            alert('ë³µìŠµí•  í‹€ë¦° ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤!');
            return;
        }
        
        // Create custom word list for review
        this.reviewMode = true;
        this.reviewWords = wrongAnswers;
        this.currentTheme = themeKey;
        this.usedIndices = [];
        this.totalQuestions = 0;
        this.correctAnswers = 0;
        
        this.currentThemeLabel.textContent = `${vocabularyThemes[themeKey].name} (ë³µìŠµ ëª¨ë“œ)`;
        this.updateScore();
        
        this.themeSelector.style.display = 'none';
        this.mainContent.style.display = 'block';
        
        this.loadReviewWord();
    }
    
    loadReviewWord() {
        if (this.usedIndices.length >= this.reviewWords.length) {
            // Review completed
            this.reviewMode = false;
            this.showCompletionModal();
            return;
        }
        
        let randomIndex;
        do {
            randomIndex = Math.floor(Math.random() * this.reviewWords.length);
        } while (this.usedIndices.includes(randomIndex));
        
        this.usedIndices.push(randomIndex);
        this.currentWordIndex = randomIndex;
        
        const reviewWord = this.reviewWords[randomIndex];
        
        this.wordElement.textContent = reviewWord.word;
        this.wordTypeElement.textContent = reviewWord.type;
        
        // Generate choices for review word
        const choiceData = this.generateChoicesForReview(reviewWord);
        this.currentChoices = choiceData.choices;
        this.correctChoiceIndex = choiceData.correctIndex;
        this.selectedChoice = null;
        
        // Update choice elements
        for (let i = 0; i < 4; i++) {
            const choiceElement = document.getElementById(`choice${i}`);
            const choiceItem = choiceElement.parentElement;
            
            choiceElement.textContent = this.currentChoices[i] || '';
            choiceItem.className = 'choice-item';
            // Remove all selection/result classes
            choiceItem.classList.remove('correct', 'incorrect', 'selected');
        }
        
        this.feedbackElement.textContent = '';
        this.feedbackElement.className = 'feedback';
        this.nextBtn.style.display = 'none';
        
        // Reset typing mode state for loadReviewWord
        if (this.typingMode) {
            this.typingInput.value = '';
            this.typingInput.disabled = false;
            this.submitTypingBtn.disabled = false;
            this.typingInput.style.borderColor = '';
            this.typingInput.focus();
        }
        
        // Update question progress counter
        this.updateQuestionProgress();
        this.updateQuizProgress();
        
        // Record question start time for accurate study time tracking
        this.sessionStats.questionStartTime = Date.now();
    }
    
    generateChoicesForReview(reviewWord) {
        const choices = [reviewWord.meaning];
        
        // Get all possible meanings from all themes except the correct one
        const allMeanings = [];
        Object.keys(vocabularyThemes).forEach(themeKey => {
            vocabularyThemes[themeKey].words.forEach(word => {
                if (word.meaning !== reviewWord.meaning) {
                    allMeanings.push(word.meaning);
                }
            });
        });
        
        // Add random wrong choices
        while (choices.length < 4 && allMeanings.length > 0) {
            const randomIndex = Math.floor(Math.random() * allMeanings.length);
            const randomMeaning = allMeanings[randomIndex];
            
            if (!choices.includes(randomMeaning)) {
                choices.push(randomMeaning);
            }
            allMeanings.splice(randomIndex, 1);
        }
        
        // Shuffle choices
        const shuffledChoices = [...choices];
        for (let i = shuffledChoices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffledChoices[i], shuffledChoices[j]] = [shuffledChoices[j], shuffledChoices[i]];
        }
        
        return {
            choices: shuffledChoices,
            correctIndex: shuffledChoices.indexOf(reviewWord.meaning)
        };
    }
    
    // Statistics Dashboard Methods
    showStatsDashboard() {
        this.themeSelector.style.display = 'none';
        this.statsDashboard.style.display = 'block';
        this.populateStatsDashboard();
    }
    
    hideStatsDashboard() {
        this.statsDashboard.style.display = 'none';
        this.themeSelector.style.display = 'block';
    }
    
    populateStatsDashboard() {
        this.updateOverviewStats();
        this.updateThemeStats();
        this.updateReviewStats();
    }
    
    updateOverviewStats() {
        // Learning streak
        document.getElementById('learningStreak').textContent = this.userProgress.learningStreak;
        
        // Total words learned (accurate count)
        const totalWords = this.userProgress.totalWordsLearned || this.userProgress.learnedWords.length || 0;
        document.getElementById('totalWordsLearned').textContent = totalWords;
        
        // Total study time (convert milliseconds to minutes)
        const totalMinutes = Math.round((this.userProgress.actualStudyTime || this.userProgress.totalSessionTime || 0) / (1000 * 60));
        document.getElementById('totalStudyTime').textContent = `${totalMinutes}ë¶„`;
        
        // Average score
        const scores = Object.values(this.userProgress.bestScores);
        const averageScore = scores.length > 0 ? Math.round(scores.reduce((a, b) => a + b, 0) / scores.length) : 0;
        document.getElementById('averageScore').textContent = `${averageScore}ì `;
    }
    
    formatDateToKorean(dateString) {
        if (!dateString || dateString === 'ì—†ìŒ') return 'ì—†ìŒ';
        
        try {
            const date = new Date(dateString);
            const now = new Date();
            
            // ê°™ì€ ë‚ ì¸ì§€ í™•ì¸
            if (date.toDateString() === now.toDateString()) {
                return 'ì˜¤ëŠ˜';
            }
            
            // ì–´ì œì¸ì§€ í™•ì¸
            const yesterday = new Date(now);
            yesterday.setDate(yesterday.getDate() - 1);
            if (date.toDateString() === yesterday.toDateString()) {
                return 'ì–´ì œ';
            }
            
            // ì¼ì£¼ì¼ ì´ë‚´ì¸ì§€ í™•ì¸
            const weekAgo = new Date(now);
            weekAgo.setDate(weekAgo.getDate() - 7);
            if (date > weekAgo) {
                const daysAgo = Math.floor((now - date) / (1000 * 60 * 60 * 24));
                return `${daysAgo}ì¼ ì „`;
            }
            
            // ê·¸ ì™¸ì˜ ê²½ìš° í•œêµ­ì–´ ë‚ ì§œ í˜•ì‹ìœ¼ë¡œ
            const year = date.getFullYear();
            const month = date.getMonth() + 1;
            const day = date.getDate();
            
            // ì˜¬í•´ì¸ ê²½ìš° ë…„ë„ ìƒëµ
            if (year === now.getFullYear()) {
                return `${month}ì›” ${day}ì¼`;
            } else {
                return `${year}ë…„ ${month}ì›” ${day}ì¼`;
            }
        } catch (error) {
            console.warn('Date formatting error:', error);
            return dateString;
        }
    }
    
    updateThemeStats() {
        const themeStatsGrid = document.getElementById('themeStatsGrid');
        themeStatsGrid.innerHTML = '';
        
        Object.keys(vocabularyThemes).forEach(themeKey => {
            const theme = vocabularyThemes[themeKey];
            const themeProgress = this.userProgress.completedThemes[themeKey];
            const bestScore = this.userProgress.bestScores[themeKey] || 0;
            const wrongAnswersCount = Object.keys(this.userProgress.wrongAnswers[themeKey] || {}).length;
            
            const themeStatItem = document.createElement('div');
            themeStatItem.className = 'theme-stat-item';
            
            const completionCount = themeProgress ? themeProgress.timesCompleted : 0;
            const lastCompleted = themeProgress ? this.formatDateToKorean(themeProgress.lastCompleted) : 'ì—†ìŒ';
            
            themeStatItem.innerHTML = `
                <div class="theme-stat-header">
                    <span class="theme-stat-icon">${theme.icon}</span>
                    <span class="theme-stat-name">${theme.name}</span>
                </div>
                <div class="theme-stat-details">
                    <div class="theme-stat-detail">
                        <span class="theme-stat-label">ìµœê³  ì ìˆ˜</span>
                        <span class="theme-stat-value">${bestScore}ì </span>
                    </div>
                    <div class="theme-stat-detail">
                        <span class="theme-stat-label">ì™„ì£¼ íšŸìˆ˜</span>
                        <span class="theme-stat-value">${completionCount}íšŒ</span>
                    </div>
                    <div class="theme-stat-detail">
                        <span class="theme-stat-label">í‹€ë¦° ë¬¸ì œ</span>
                        <span class="theme-stat-value">${wrongAnswersCount}ê°œ</span>
                    </div>
                    <div class="theme-stat-detail">
                        <span class="theme-stat-label">ë§ˆì§€ë§‰ í•™ìŠµ</span>
                        <span class="theme-stat-value">${lastCompleted}</span>
                    </div>
                </div>
            `;
            
            themeStatsGrid.appendChild(themeStatItem);
        });
    }
    
    updateReviewStats() {
        const reviewSummary = document.getElementById('reviewSummary');
        
        let totalWrongAnswers = 0;
        let themesWithWrongAnswers = 0;
        
        Object.keys(this.userProgress.wrongAnswers).forEach(themeKey => {
            const wrongCount = Object.keys(this.userProgress.wrongAnswers[themeKey] || {}).length;
            if (wrongCount > 0) {
                totalWrongAnswers += wrongCount;
                themesWithWrongAnswers++;
            }
        });
        
        let reviewMessage = '';
        if (totalWrongAnswers === 0) {
            reviewMessage = 'ì¶•í•˜í•©ë‹ˆë‹¤! ë³µìŠµí•  í‹€ë¦° ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤! ğŸ‰';
        } else {
            reviewMessage = `ë³µìŠµì´ í•„ìš”í•œ ë¬¸ì œë“¤ì´ ìˆìŠµë‹ˆë‹¤. ì§€ì†ì ì¸ ë³µìŠµìœ¼ë¡œ ì™„ë²½í•˜ê²Œ ë§ˆìŠ¤í„°í•´ë³´ì„¸ìš”! ğŸ’ª`;
        }
        
        reviewSummary.innerHTML = `
            <div class="review-summary-title">${reviewMessage}</div>
            <div class="review-summary-stats">
                <div class="review-summary-stat">
                    <div class="review-summary-number">${totalWrongAnswers}</div>
                    <div class="review-summary-label">ì´ í‹€ë¦° ë¬¸ì œ</div>
                </div>
                <div class="review-summary-stat">
                    <div class="review-summary-number">${themesWithWrongAnswers}</div>
                    <div class="review-summary-label">ë³µìŠµ í•„ìš” í…Œë§ˆ</div>
                </div>
                <div class="review-summary-stat">
                    <div class="review-summary-number">${6 - themesWithWrongAnswers}</div>
                    <div class="review-summary-label">ì™„ë²½ ë§ˆìŠ¤í„° í…Œë§ˆ</div>
                </div>
            </div>
        `;
    }
    
    // Social Features Methods
    async shareScore(score, accuracy, themeName) {
        try {
            console.log('shareScore called:', { score, accuracy, themeName });
            
            // Generate score card image
            const imageBlob = await this.generateScoreCard(score, accuracy, themeName);
            console.log('Image blob generated:', imageBlob);
            
            if (navigator.share && navigator.canShare) {
                console.log('Navigator.share available');
                const testFile = new File([imageBlob], 'score.png', { type: 'image/png' });
                const canShareFiles = navigator.canShare({ files: [testFile] });
                console.log('Can share files:', canShareFiles);
                
                if (canShareFiles) {
                    console.log('Attempting to share with files...');
                    // Share with image (supported on mobile)
                    const file = new File([imageBlob], 'english-master-score.png', { type: 'image/png' });
                    await navigator.share({
                        title: 'ğŸ¯ ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„° - ì ìˆ˜ ê³µìœ ',
                        text: `${themeName} í…Œë§ˆì—ì„œ ${score}ì ì„ ë‹¬ì„±í–ˆì–´ìš”! ğŸ‰`,
                        files: [file]
                    });
                    console.log('Share completed successfully!');
                } else {
                    console.log('File sharing not supported, using fallback...');
                    // Fallback: download image and show share text
                    this.downloadScoreCard(imageBlob, `ì˜ì–´ë‹¨ì–´ë§ˆìŠ¤í„°_${themeName}_${score}ì .png`);
                    this.showToast('ğŸ“¸ ì ìˆ˜ ì¹´ë“œê°€ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!\nì´ë¯¸ì§€ë¥¼ SNSì— ì˜¬ë ¤ë³´ì„¸ìš”!');
                }
            } else {
                console.log('Navigator.share not available, using fallback...');
                // Fallback: download image and show share text
                this.downloadScoreCard(imageBlob, `ì˜ì–´ë‹¨ì–´ë§ˆìŠ¤í„°_${themeName}_${score}ì .png`);
                this.showToast('ğŸ“¸ ì ìˆ˜ ì¹´ë“œê°€ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!\nì´ë¯¸ì§€ë¥¼ SNSì— ì˜¬ë ¤ë³´ì„¸ìš”!');
            }
        } catch (error) {
            console.error('Error sharing score:', error);
            // Fallback to text sharing
            const correctAnswers = Math.round((accuracy / 100) * 40);
            const shareText = `ğŸ¯ ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„°ì—ì„œ ${themeName} í…Œë§ˆë¥¼ ì™„ì£¼í–ˆì–´ìš”!\nğŸ“Š ì ìˆ˜: ${score}ì  | ì •ë‹µ: ${correctAnswers}/40\n\ní•¨ê»˜ ì˜ì–´ ë‹¨ì–´ë¥¼ ë§ˆìŠ¤í„°í•´ë³´ì„¸ìš”! ğŸš€`;
            const appUrl = 'https://prepaid114.github.io/prepaid114/';
            this.fallbackShare(shareText, appUrl);
        }
    }
    
    shareStats() {
        const streak = this.userProgress.learningStreak;
        const totalWords = this.userProgress.totalWordsLearned || this.userProgress.learnedWords.length;
        const totalMinutes = Math.round((this.userProgress.actualStudyTime || this.userProgress.totalSessionTime) / (1000 * 60));
        const completedThemes = Object.keys(this.userProgress.completedThemes).length;
        
        const shareText = `ğŸ“š ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„° í•™ìŠµ í˜„í™© ğŸ“š\n\nğŸ”¥ ì—°ì† í•™ìŠµ: ${streak}ì¼\nğŸ“– í•™ìŠµí•œ ë‹¨ì–´: ${totalWords}ê°œ\nâ±ï¸ ì´ í•™ìŠµì‹œê°„: ${totalMinutes}ë¶„\nğŸ¯ ì™„ë£Œí•œ í…Œë§ˆ: ${completedThemes}ê°œ\n\nê¾¸ì¤€í•œ í•™ìŠµìœ¼ë¡œ ì˜ì–´ ì‹¤ë ¥ì„ í‚¤ì›Œê°€ê³  ìˆì–´ìš”! ğŸ’ª`;
        const appUrl = 'https://prepaid114.github.io/prepaid114/';
        
        if (navigator.share) {
            navigator.share({
                title: 'ğŸ“š ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„° - í•™ìŠµ í†µê³„',
                text: shareText,
                url: appUrl
            }).catch(err => {
                console.log('Error sharing:', err);
                this.fallbackShare(shareText, appUrl);
            });
        } else {
            this.fallbackShare(shareText, appUrl);
        }
    }
    
    async challengeFriends() {
        // í˜„ì¬ ì‚¬ìš©ìì˜ ìµœê³  ê¸°ë¡ ê°€ì ¸ì˜¤ê¸°
        const bestScores = this.userProgress.bestScores;
        const availableThemes = Object.keys(bestScores).filter(theme => bestScores[theme] > 0);
        
        if (availableThemes.length === 0) {
            this.showToast('ë¨¼ì € í…Œë§ˆë¥¼ ì™„ì£¼í•œ í›„ ì¹œêµ¬ì—ê²Œ ë„ì „ì¥ì„ ë³´ë‚¼ ìˆ˜ ìˆì–´ìš”!');
            return;
        }
        
        // ë„ì „í•  í…Œë§ˆ ì„ íƒ (ê°€ì¥ ë†’ì€ ì ìˆ˜ì˜ í…Œë§ˆ)
        const bestTheme = Object.keys(bestScores).reduce((a, b) => 
            bestScores[a] > bestScores[b] ? a : b
        );
        const bestScore = bestScores[bestTheme];
        const themeName = vocabularyThemes[bestTheme].name;
        
        // ì±Œë¦°ì§€ ìƒì„±
        const challenge = this.createChallenge(bestTheme, bestScore, themeName);
        
        try {
            // ì±Œë¦°ì§€ ì¹´ë“œ ì´ë¯¸ì§€ ìƒì„±
            const imageBlob = await this.generateChallengeCard(challenge);
            
            if (navigator.share && navigator.canShare && navigator.canShare({ files: [new File([imageBlob], 'challenge.png', { type: 'image/png' })] })) {
                // Share with image
                const file = new File([imageBlob], 'english-master-challenge.png', { type: 'image/png' });
                await navigator.share({
                    title: 'ğŸ¯ ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„° - ë„ì „ì¥',
                    text: `${themeName} í…Œë§ˆì—ì„œ ${bestScore}ì ì— ë„ì „í•´ë³´ì„¸ìš”! ğŸ†`,
                    files: [file]
                });
            } else {
                // Fallback: download image and show challenge URL
                this.downloadScoreCard(imageBlob, `ì˜ì–´ë‹¨ì–´ë§ˆìŠ¤í„°_ë„ì „ì¥_${themeName}.png`);
                const challengeUrl = `${window.location.origin}${window.location.pathname}?challenge=${challenge.id}`;
                
                await navigator.clipboard.writeText(challengeUrl);
                this.showToast('ğŸ¯ ë„ì „ì¥ ì´ë¯¸ì§€ê°€ ë‹¤ìš´ë¡œë“œë˜ê³  ë§í¬ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!\nì¹œêµ¬ì—ê²Œ ì´ë¯¸ì§€ì™€ ë§í¬ë¥¼ í•¨ê»˜ ë³´ë‚´ë³´ì„¸ìš”!');
            }
        } catch (error) {
            console.error('Error creating challenge:', error);
            // Text fallback
            const challengeUrl = `${window.location.origin}${window.location.pathname}?challenge=${challenge.id}`;
            const challengeText = `ğŸ¯ ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„° ë„ì „ì¥! ğŸ¯\n\n${themeName} í…Œë§ˆì—ì„œ ë‚´ ê¸°ë¡ ${bestScore}ì ì„ ë„˜ì–´ë³´ì„¸ìš”!\n\n${challengeUrl}`;
            this.fallbackShare(challengeText, '');
        }
    }
    
    createChallenge(themeKey, targetScore, themeName) {
        const challengeId = this.generateChallengeId();
        const challenge = {
            id: challengeId,
            theme: themeKey,
            themeName: themeName,
            targetScore: targetScore,
            createdAt: Date.now(),
            creatorName: 'ë„ì „ì', // ì¶”í›„ ì‚¬ìš©ì ì´ë¦„ ê¸°ëŠ¥ ì¶”ê°€ ì‹œ ì‚¬ìš©
        };
        
        // LocalStorageì— ì±Œë¦°ì§€ ì €ì¥
        const challenges = JSON.parse(localStorage.getItem('englishMasterChallenges') || '{}');
        challenges[challengeId] = challenge;
        localStorage.setItem('englishMasterChallenges', JSON.stringify(challenges));
        
        return challenge;
    }
    
    generateChallengeId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }
    
    async generateChallengeCard(challenge) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = 800;
        canvas.height = 800;
        
        const themeColors = this.getThemeColors(challenge.theme);
        const themeIcon = vocabularyThemes[challenge.theme].icon;
        
        // ë°°ê²½ (ë„ì „ì¥ ëŠë‚Œì˜ ë‹¤ë¥¸ ìƒ‰ìƒ)
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, '#ff6b6b');
        gradient.addColorStop(0.5, '#ffd93d');
        gradient.addColorStop(1, '#6c5ce7');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // ì¹´ë“œ ë°°ê²½
        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.roundRect(50, 80, canvas.width - 100, canvas.height - 160, 30);
        ctx.fill();
        
        // ë„ì „ì¥ íƒ€ì´í‹€
        ctx.fillStyle = '#e74c3c';
        ctx.font = 'bold 52px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('ğŸ¯ ë„ì „ì¥! ğŸ¯', canvas.width / 2, 180);
        
        // í…Œë§ˆ ì •ë³´
        ctx.font = '60px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = '#2c3e50';
        ctx.fillText(themeIcon, canvas.width / 2, 280);
        
        ctx.font = 'bold 32px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillText(challenge.themeName, canvas.width / 2, 330);
        
        // ë„ì „ ë©”ì‹œì§€
        ctx.font = 'bold 28px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = '#666';
        ctx.fillText('ì´ ì ìˆ˜ë¥¼ ë„˜ì–´ë³´ì„¸ìš”!', canvas.width / 2, 400);
        
        // ëª©í‘œ ì ìˆ˜
        ctx.font = 'bold 100px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = themeColors.accent;
        ctx.fillText(`${challenge.targetScore}ì `, canvas.width / 2, 520);
        
        // ë„ì „ ë²„íŠ¼ íš¨ê³¼
        ctx.fillStyle = '#e74c3c';
        ctx.roundRect(250, 560, 300, 60, 30);
        ctx.fill();
        
        ctx.fillStyle = 'white';
        ctx.font = 'bold 28px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillText('ë„ì „í•˜ê¸°!', canvas.width / 2, 600);
        
        // ì•± ì •ë³´
        ctx.font = '24px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = '#999';
        ctx.fillText('ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„°', canvas.width / 2, 680);
        ctx.font = '20px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillText('prepaid114.github.io/prepaid114', canvas.width / 2, 720);
        
        return new Promise(resolve => {
            canvas.toBlob(resolve, 'image/png', 0.9);
        });
    }
    
    async copyAppLink() {
        const appUrl = 'https://prepaid114.github.io/prepaid114/';
        const linkText = `ğŸ¯ ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„°\n\ní…Œë§ˆë³„ ì˜ì–´ ë‹¨ì–´ í•™ìŠµ ì•±\nğŸ“š 240ê°œ ë‹¨ì–´ | ğŸ”Š ì›ì–´ë¯¼ ë°œìŒ | ğŸ“± ëª¨ë°”ì¼ ìµœì í™”\n\n${appUrl}`;
        
        try {
            if (navigator.clipboard) {
                await navigator.clipboard.writeText(linkText);
                this.showToast('âœ… ë§í¬ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
            } else {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = linkText;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                this.showToast('âœ… ë§í¬ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
            }
        } catch (err) {
            console.error('Failed to copy link:', err);
            this.showToast('âŒ ë§í¬ ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì§ì ‘ ë³µì‚¬í•´ì£¼ì„¸ìš”.');
            // Show the link in an alert as fallback
            alert(`ë§í¬ë¥¼ ì§ì ‘ ë³µì‚¬í•´ì£¼ì„¸ìš”:\n\n${linkText}`);
        }
    }
    
    fallbackShare(text, url) {
        const fullText = `${text}\n\n${url}`;
        
        // Try to copy to clipboard first
        if (navigator.clipboard) {
            navigator.clipboard.writeText(fullText).then(() => {
                this.showToast('ğŸ“‹ í…ìŠ¤íŠ¸ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!\nì¹´ì¹´ì˜¤í†¡, ë¬¸ì ë“±ì— ë¶™ì—¬ë„£ê¸° í•˜ì„¸ìš”.');
            }).catch(() => {
                this.showShareAlert(fullText);
            });
        } else {
            this.showShareAlert(fullText);
        }
    }
    
    showShareAlert(text) {
        alert(`ë‹¤ìŒ ë‚´ìš©ì„ ë³µì‚¬í•´ì„œ ê³µìœ í•´ì£¼ì„¸ìš”:\n\n${text}`);
    }
    
    showToast(message) {
        // Create toast notification
        const toast = document.createElement('div');
        toast.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            z-index: 10000;
            font-size: 0.9rem;
            text-align: center;
            max-width: 90%;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        `;
        toast.textContent = message;
        
        document.body.appendChild(toast);
        
        // Remove toast after 3 seconds
        setTimeout(() => {
            if (document.body.contains(toast)) {
                document.body.removeChild(toast);
            }
        }, 3000);
    }
    
    // Score Card Image Generation
    async generateScoreCard(score, accuracy, themeName) {
        console.log('Starting canvas generation...');
        
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        if (!ctx) {
            throw new Error('Canvas 2D context not supported');
        }
        
        // Canvas í¬ê¸° ì„¤ì • (Instagram Square format)
        canvas.width = 800;
        canvas.height = 800;
        console.log('Canvas size set:', canvas.width, canvas.height);
        
        // í…Œë§ˆë³„ ìƒ‰ìƒ ë° ì•„ì´ì½˜ ê°€ì ¸ì˜¤ê¸°
        const themeKey = Object.keys(vocabularyThemes).find(key => 
            vocabularyThemes[key].name === themeName
        );
        const themeIcon = themeKey ? vocabularyThemes[themeKey].icon : 'ğŸ“š';
        const themeColors = this.getThemeColors(themeKey);
        
        console.log('Canvas debug:', { themeKey, themeIcon, themeColors, themeName });
        
        // ë‹¨ìˆœí•œ ë°°ê²½ìƒ‰ìœ¼ë¡œ ì‹œì‘ (ê·¸ë¼ë°ì´ì…˜ ëŒ€ì‹ )
        ctx.fillStyle = themeColors.primary || '#4ecdc4';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        console.log('Solid background applied');
        
        // ì¹´ë“œ ì»¨í…Œì´ë„ˆ (roundRect ëŒ€ì‹  ì¼ë°˜ rect ì‚¬ìš©)
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.fillRect(50, 100, canvas.width - 100, canvas.height - 200);
        console.log('Card container drawn');
        
        // ì œëª© (ë” ì§„í•œ ìƒ‰ìƒê³¼ í° ê¸€ì”¨)
        ctx.fillStyle = '#1a252f';
        ctx.font = 'bold 36px Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('ğŸ¯ ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„°', canvas.width / 2, 170);
        console.log('Title drawn');
        
        // êµ¬ë¶„ì„  ì¶”ê°€
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(200, 200);
        ctx.lineTo(600, 200);
        ctx.stroke();
        
        // í…Œë§ˆ ì•„ì´ì½˜ (ë” í¬ê²Œ)
        ctx.font = '80px Arial, sans-serif';
        ctx.fillText(themeIcon, canvas.width / 2, 290);
        console.log('Theme icon drawn');
        
        // í…Œë§ˆ ì´ë¦„ (ë” ì§„í•œ ìƒ‰ìƒ)
        ctx.font = 'bold 32px Arial, sans-serif';
        ctx.fillStyle = '#1a252f';
        ctx.fillText(themeName, canvas.width / 2, 340);
        console.log('Theme name drawn');
        
        // ì ìˆ˜ (ë©”ì¸, ë” ê°•ì¡°)
        ctx.font = 'bold 120px Arial, sans-serif';
        ctx.fillStyle = themeColors.accent || '#16a085';
        ctx.fillText(`${score}ì `, canvas.width / 2, 480);
        console.log('Score drawn');
        
        // ì •ë‹µ ê°œìˆ˜ (ë” ì§„í•œ ìƒ‰ìƒê³¼ í° ê¸€ì”¨)
        let correctAnswers, totalQuestions;
        if (typeof accuracy === 'string' && accuracy.includes('/')) {
            // "2/5" í˜•ì‹ì¸ ê²½ìš° (ë³µìŠµ ëª¨ë“œ ë“±)
            const parts = accuracy.split('/');
            correctAnswers = parseInt(parts[0]) || 0;
            totalQuestions = parseInt(parts[1]) || 40;
        } else {
            // í¼ì„¼íŠ¸ í˜•ì‹ì¸ ê²½ìš° (ì¼ë°˜ ëª¨ë“œ)
            totalQuestions = 40;
            correctAnswers = Math.round((accuracy / 100) * totalQuestions);
        }
        ctx.font = 'bold 32px Arial, sans-serif';
        ctx.fillStyle = '#34495e';
        ctx.fillText(`ì •ë‹µ ê°œìˆ˜: ${correctAnswers}/${totalQuestions}`, canvas.width / 2, 540);
        console.log('Accuracy drawn');
        
        // êµ¬ë¶„ì„  ì¶”ê°€
        ctx.strokeStyle = '#ddd';
        ctx.beginPath();
        ctx.moveTo(200, 570);
        ctx.lineTo(600, 570);
        ctx.stroke();
        
        // í•˜ë‹¨ ë¡œê³  (ë” ì‘ê²Œ)
        ctx.font = '18px Arial, sans-serif';
        ctx.fillStyle = '#7f8c8d';
        ctx.fillText('prepaid114.github.io/prepaid114', canvas.width / 2, 600);
        console.log('Footer drawn');
        
        console.log('Canvas rendering completed, converting to blob...');
        
        // Canvas to Blob
        return new Promise(resolve => {
            canvas.toBlob(blob => {
                console.log('Blob conversion completed:', blob);
                resolve(blob);
            }, 'image/png', 0.9);
        });
    }
    
    getThemeColors(themeKey) {
        const colorMap = {
            business: { primary: '#ff6b6b', secondary: '#ee5a24', accent: '#e74c3c' },
            science: { primary: '#4ecdc4', secondary: '#44a08d', accent: '#16a085' },
            travel: { primary: '#f093fb', secondary: '#f5576c', accent: '#e91e63' },
            daily: { primary: '#a8edea', secondary: '#fed6e3', accent: '#ff9a56' },
            academic: { primary: '#667eea', secondary: '#764ba2', accent: '#5a6fd8' },
            technology: { primary: '#ff9a56', secondary: '#ff6b6b', accent: '#ff5722' }
        };
        
        return colorMap[themeKey] || colorMap.academic;
    }
    
    downloadScoreCard(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
    
    // Challenge System
    checkChallengeMode() {
        const urlParams = new URLSearchParams(window.location.search);
        const challengeId = urlParams.get('challenge');
        
        if (challengeId) {
            const challenges = JSON.parse(localStorage.getItem('englishMasterChallenges') || '{}');
            const challenge = challenges[challengeId];
            
            if (challenge) {
                this.startChallengeMode(challenge);
                return true;
            } else {
                this.showToast('âŒ ìœ íš¨í•˜ì§€ ì•Šì€ ë„ì „ì¥ì…ë‹ˆë‹¤.');
                // URLì—ì„œ ì±Œë¦°ì§€ íŒŒë¼ë¯¸í„° ì œê±°
                window.history.replaceState({}, document.title, window.location.pathname);
            }
        }
        return false;
    }
    
    startChallengeMode(challenge) {
        this.challengeMode = true;
        this.currentChallenge = challenge;
        
        // ì±Œë¦°ì§€ ì •ë³´ í‘œì‹œ
        this.showChallengeInfo(challenge);
    }
    
    showChallengeInfo(challenge) {
        // ê¸°ì¡´ ìš”ì†Œë“¤ ìˆ¨ê¸°ê¸°
        this.themeSelector.style.display = 'none';
        this.mainContent.style.display = 'none';
        
        // ì±Œë¦°ì§€ ì •ë³´ ëª¨ë‹¬ ìƒì„±
        this.createChallengeModal(challenge);
    }
    
    createChallengeModal(challenge) {
        // ê¸°ì¡´ ì±Œë¦°ì§€ ëª¨ë‹¬ì´ ìˆìœ¼ë©´ ì œê±°
        const existingModal = document.getElementById('challengeModal');
        if (existingModal) {
            existingModal.remove();
        }
        
        const modal = document.createElement('div');
        modal.id = 'challengeModal';
        modal.className = 'modal-overlay';
        modal.style.display = 'flex';
        
        const themeIcon = vocabularyThemes[challenge.theme].icon;
        const createdDate = new Date(challenge.createdAt).toLocaleDateString('ko-KR');
        
        modal.innerHTML = `
            <div class="modal-content challenge-modal-content">
                <div class="challenge-header">
                    <h2>ğŸ¯ ë„ì „ì¥ì´ ë„ì°©í–ˆì–´ìš”!</h2>
                </div>
                
                <div class="challenge-info">
                    <div class="challenge-theme">
                        <span class="challenge-theme-icon">${themeIcon}</span>
                        <div class="challenge-theme-name">${challenge.themeName}</div>
                    </div>
                    
                    <div class="challenge-target">
                        <div class="challenge-label">ëª©í‘œ ì ìˆ˜</div>
                        <div class="challenge-score">${challenge.targetScore}ì </div>
                    </div>
                    
                    <div class="challenge-message">
                        <p>ì¹œêµ¬ê°€ ${challenge.themeName} í…Œë§ˆì—ì„œ <strong>${challenge.targetScore}ì </strong>ì„ ë‹¬ì„±í–ˆì–´ìš”!</p>
                        <p>ì´ ê¸°ë¡ì„ ë„˜ì–´ì„œ ë„ì „ì— ì„±ê³µí•´ë³´ì„¸ìš”! ğŸ†</p>
                    </div>
                    
                    <div class="challenge-date">
                        ë„ì „ì¥ ìƒì„±ì¼: ${createdDate}
                    </div>
                </div>
                
                <div class="challenge-actions">
                    <button class="action-btn primary" id="acceptChallengeBtn">
                        ğŸ”¥ ë„ì „ ìˆ˜ë½í•˜ê¸°
                    </button>
                    <button class="action-btn secondary" id="declineChallengeBtn">
                        ë‚˜ì¤‘ì— í•˜ê¸°
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
        document.getElementById('acceptChallengeBtn').onclick = () => {
            modal.remove();
            this.acceptChallenge(challenge);
        };
        
        document.getElementById('declineChallengeBtn').onclick = () => {
            modal.remove();
            window.history.replaceState({}, document.title, window.location.pathname);
            this.showThemeSelector();
        };
        
        // ë°°ê²½ í´ë¦­ìœ¼ë¡œ ë‹«ê¸°
        modal.onclick = (e) => {
            if (e.target === modal) {
                modal.remove();
                window.history.replaceState({}, document.title, window.location.pathname);
                this.showThemeSelector();
            }
        };
    }
    
    acceptChallenge(challenge) {
        // ì±Œë¦°ì§€ ëª¨ë“œë¡œ ê²Œì„ ì‹œì‘
        this.challengeMode = true;
        this.currentChallenge = challenge;
        
        // í•´ë‹¹ í…Œë§ˆë¡œ ë°”ë¡œ ì‹œì‘
        this.selectTheme(challenge.theme);
        
        // ì±Œë¦°ì§€ ëª¨ë“œ UI í‘œì‹œ
        this.updateChallengeUI();
    }
    
    updateChallengeUI() {
        if (this.challengeMode && this.currentChallenge) {
            // í…Œë§ˆ ë¼ë²¨ ì—…ë°ì´íŠ¸
            this.currentThemeLabel.textContent = `${this.currentChallenge.themeName} (ë„ì „ ëª¨ë“œ ğŸ¯)`;
            
            // í—¤ë”ì— ë„ì „ ì •ë³´ ì¶”ê°€
            const challengeInfo = document.createElement('div');
            challengeInfo.className = 'challenge-info-bar';
            challengeInfo.innerHTML = `
                <div class="challenge-target-info">
                    ğŸ¯ ëª©í‘œ: ${this.currentChallenge.targetScore}ì  ë„˜ê¸°
                </div>
            `;
            
            // ê¸°ì¡´ ì±Œë¦°ì§€ ì •ë³´ê°€ ìˆìœ¼ë©´ ì œê±°
            const existingInfo = document.querySelector('.challenge-info-bar');
            if (existingInfo) {
                existingInfo.remove();
            }
            
            // í˜„ì¬ í…Œë§ˆ ì„¹ì…˜ì— ì¶”ê°€
            const currentThemeSection = document.querySelector('.current-theme');
            currentThemeSection.appendChild(challengeInfo);
        }
    }
    
    checkChallengeSuccess(finalScore) {
        if (this.challengeMode && this.currentChallenge) {
            const success = finalScore > this.currentChallenge.targetScore;
            this.showChallengeResult(finalScore, success);
            return true;
        }
        return false;
    }
    
    showChallengeResult(finalScore, success) {
        setTimeout(() => {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.style.display = 'flex';
            
            const resultIcon = success ? 'ğŸ†' : 'ğŸ˜…';
            const resultTitle = success ? 'ë„ì „ ì„±ê³µ!' : 'ë„ì „ ì‹¤íŒ¨...';
            const resultMessage = success 
                ? `ì¶•í•˜í•©ë‹ˆë‹¤! ${this.currentChallenge.targetScore}ì ì„ ë„˜ì–´ ${finalScore}ì ì„ ë‹¬ì„±í–ˆì–´ìš”!`
                : `ì•„ì‰½ê²Œë„ ${this.currentChallenge.targetScore}ì ì„ ë„˜ì§€ ëª»í–ˆì–´ìš”. ${finalScore}ì ìœ¼ë¡œ ë„ì „ ì‹¤íŒ¨! ë‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”!`;
            
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="completion-celebration">${resultIcon}</div>
                    <h2 class="completion-title">${resultTitle}</h2>
                    <div class="challenge-result-info">
                        <div class="result-scores">
                            <div class="score-comparison">
                                <div class="target-score">
                                    <span class="score-label">ëª©í‘œ ì ìˆ˜</span>
                                    <span class="score-value">${this.currentChallenge.targetScore}ì </span>
                                </div>
                                <div class="vs">VS</div>
                                <div class="my-score ${success ? 'success' : 'fail'}">
                                    <span class="score-label">ë‚´ ì ìˆ˜</span>
                                    <span class="score-value">${finalScore}ì </span>
                                </div>
                            </div>
                        </div>
                        <p class="result-message">${resultMessage}</p>
                    </div>
                    <div class="completion-actions">
                        <button class="action-btn primary" id="shareResultBtn">
                            ğŸ“± ê²°ê³¼ ê³µìœ í•˜ê¸°
                        </button>
                        <button class="action-btn secondary" id="retrychallengeBtn">
                            ğŸ”„ ë‹¤ì‹œ ë„ì „í•˜ê¸°
                        </button>
                        <button class="action-btn secondary" id="backToMainBtn">
                            ğŸ  ë©”ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
            document.getElementById('shareResultBtn').onclick = () => {
                this.shareChallengeResult(finalScore, success);
            };
            
            document.getElementById('retrychallengeBtn').onclick = () => {
                modal.remove();
                this.selectTheme(this.currentChallenge.theme);
            };
            
            document.getElementById('backToMainBtn').onclick = () => {
                modal.remove();
                this.challengeMode = false;
                this.currentChallenge = null;
                window.history.replaceState({}, document.title, window.location.pathname);
                this.showThemeSelector();
            };
        }, 500);
    }
    
    async shareChallengeResult(myScore, success) {
        try {
            const imageBlob = await this.generateChallengeResultCard(myScore, success);
            
            if (navigator.share && navigator.canShare && navigator.canShare({ files: [new File([imageBlob], 'result.png', { type: 'image/png' })] })) {
                const file = new File([imageBlob], 'challenge-result.png', { type: 'image/png' });
                await navigator.share({
                    title: 'ğŸ¯ ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„° - ë„ì „ ê²°ê³¼',
                    text: success ? 'ë„ì „ì— ì„±ê³µí–ˆì–´ìš”! ğŸ†' : 'ì•„ì‰½ê²Œ ì‹¤íŒ¨í–ˆì§€ë§Œ ë‹¤ì‹œ ë„ì „í• ê²Œìš”! ğŸ’ª',
                    files: [file]
                });
            } else {
                this.downloadScoreCard(imageBlob, `ë„ì „ê²°ê³¼_${success ? 'ì„±ê³µ' : 'ì‹¤íŒ¨'}_${myScore}ì .png`);
                this.showToast('ğŸ“¸ ë„ì „ ê²°ê³¼ê°€ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!');
            }
        } catch (error) {
            console.error('Error sharing result:', error);
            const resultText = success 
                ? `ğŸ† ë„ì „ ì„±ê³µ! ${this.currentChallenge.themeName}ì—ì„œ ${myScore}ì  ë‹¬ì„±! ëª©í‘œ ${this.currentChallenge.targetScore}ì ì„ ë„˜ì—ˆì–´ìš”!`
                : `ğŸ˜… ë„ì „ ì‹¤íŒ¨... ${this.currentChallenge.themeName}ì—ì„œ ${myScore}ì . ëª©í‘œ ${this.currentChallenge.targetScore}ì ì— ì¡°ê¸ˆ ëª» ë¯¸ì³¤ì–´ìš”!`;
            this.fallbackShare(resultText, window.location.origin + window.location.pathname);
        }
    }
    
    async generateChallengeResultCard(myScore, success) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = 800;
        canvas.height = 800;
        
        const themeColors = this.getThemeColors(this.currentChallenge.theme);
        const themeIcon = vocabularyThemes[this.currentChallenge.theme].icon;
        
        // ë°°ê²½ (ì„±ê³µ/ì‹¤íŒ¨ì— ë”°ë¥¸ ë‹¤ë¥¸ ìƒ‰ìƒ)
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        if (success) {
            gradient.addColorStop(0, '#00d2ff');
            gradient.addColorStop(1, '#3a7bd5');
        } else {
            gradient.addColorStop(0, '#ff9a9e');
            gradient.addColorStop(1, '#fad0c4');
        }
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // ì¹´ë“œ ë°°ê²½
        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.roundRect(50, 80, canvas.width - 100, canvas.height - 160, 30);
        ctx.fill();
        
        // ê²°ê³¼ ì•„ì´ì½˜ ë° ì œëª©
        ctx.font = '80px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(success ? 'ğŸ†' : 'ğŸ˜…', canvas.width / 2, 180);
        
        ctx.fillStyle = success ? '#27ae60' : '#e74c3c';
        ctx.font = 'bold 42px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillText(success ? 'ë„ì „ ì„±ê³µ!' : 'ë„ì „ ì‹¤íŒ¨', canvas.width / 2, 240);
        
        // í…Œë§ˆ ì •ë³´
        ctx.font = '40px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = '#2c3e50';
        ctx.fillText(themeIcon, canvas.width / 2, 310);
        
        ctx.font = 'bold 28px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillText(this.currentChallenge.themeName, canvas.width / 2, 350);
        
        // ì ìˆ˜ ë¹„êµ
        ctx.font = 'bold 24px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = '#666';
        ctx.fillText('ëª©í‘œ', 250, 420);
        ctx.fillText('ë‚´ ê²°ê³¼', 550, 420);
        
        ctx.font = 'bold 60px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = '#999';
        ctx.fillText(`${this.currentChallenge.targetScore}ì `, 250, 480);
        
        ctx.fillStyle = success ? '#27ae60' : '#e74c3c';
        ctx.fillText(`${myScore}ì `, 550, 480);
        
        // VS
        ctx.font = 'bold 32px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = '#333';
        ctx.fillText('VS', canvas.width / 2, 465);
        
        // ê²°ê³¼ ë©”ì‹œì§€
        ctx.font = 'bold 24px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = '#666';
        const message = success ? 'ëª©í‘œë¥¼ ë„˜ì–´ ë„ì „ì— ì„±ê³µí–ˆì–´ìš”!' : 'ì•„ì‰½ì§€ë§Œ ë‹¤ìŒ ê¸°íšŒì—! ğŸ’ª';
        ctx.fillText(message, canvas.width / 2, 560);
        
        // ì•± ì •ë³´
        ctx.font = '24px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = '#999';
        ctx.fillText('ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„°', canvas.width / 2, 650);
        ctx.font = '20px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillText('prepaid114.github.io/prepaid114', canvas.width / 2, 690);
        
        return new Promise(resolve => {
            canvas.toBlob(resolve, 'image/png', 0.9);
        });
    }
    
    initElements() {
        console.log('Initializing elements...');
        
        this.themeSelector = document.getElementById('themeSelector');
        this.themeGrid = document.getElementById('themeGrid');
        this.mainContent = document.getElementById('mainContent');
        this.currentThemeLabel = document.getElementById('currentTheme');
        this.changeThemeBtn = document.getElementById('changeThemeBtn');
        this.wordElement = document.getElementById('currentWord');
        this.wordTypeElement = document.getElementById('wordType');
        this.choicesSection = document.getElementById('choicesSection');
        this.nextBtn = document.getElementById('nextBtn');
        this.feedbackElement = document.getElementById('feedback');
        this.scoreElement = document.getElementById('score');
        this.accuracyElement = document.getElementById('accuracy');
        this.progressFill = document.getElementById('progressFill');
        this.pronunciationBtn = document.getElementById('pronunciationBtn');
        this.autoAdvanceToggle = document.getElementById('autoAdvanceToggle');
        this.questionProgress = document.getElementById('questionProgress');
        
        // Typing mode elements
        this.typingModeToggle = document.getElementById('typingModeToggle');
        this.typingSection = document.getElementById('typingSection');
        this.typingInput = document.getElementById('typingInput');
        this.submitTypingBtn = document.getElementById('submitTypingBtn');
        
        // Statistics dashboard elements
        this.statsBtn = document.getElementById('statsBtn');
        this.statsDashboard = document.getElementById('statsDashboard');
        this.closeStatsBtn = document.getElementById('closeStatsBtn');
        
        // Social feature elements
        this.shareScoreBtn = document.getElementById('shareScoreBtn');
        this.shareStatsBtn = document.getElementById('shareStatsBtn');
        this.challengeFriendsBtn = document.getElementById('challengeFriendsBtn');
        this.copyLinkBtn = document.getElementById('copyLinkBtn');
        
        // Leaderboard elements
        this.leaderboardBtn = document.getElementById('leaderboardBtn');
        this.saveToLeaderboardBtn = document.getElementById('saveToLeaderboardBtn');
        this.nicknameModal = document.getElementById('nicknameModal');
        this.leaderboardModal = document.getElementById('leaderboardModal');
        this.nicknameInput = document.getElementById('nicknameInput');
        this.saveNicknameBtn = document.getElementById('saveNicknameBtn');
        this.cancelNicknameBtn = document.getElementById('cancelNicknameBtn');
        this.closeLeaderboardBtn = document.getElementById('closeLeaderboardBtn');
        this.connectionStatus = document.getElementById('connectionStatus');
        
        // Log element states for debugging
        console.log('Elements initialized:', {
            themeSelector: !!this.themeSelector,
            themeGrid: !!this.themeGrid,
            mainContent: !!this.mainContent
        });
        
        // Verify critical elements exist
        if (!this.themeSelector || !this.themeGrid || !this.mainContent) {
            console.error('Critical elements missing:', {
                themeSelector: this.themeSelector,
                themeGrid: this.themeGrid,
                mainContent: this.mainContent
            });
            throw new Error('Critical DOM elements not found');
        }
    }
    
    initVoice() {
        // Wait for voices to load
        const setVoice = () => {
            const voices = this.speechSynthesis.getVoices();
            console.log('Available voices:', voices.map(v => `${v.name} (${v.lang})`));
            
            // Try to find the best English voice
            const englishVoices = voices.filter(voice => 
                voice.lang.startsWith('en-') && 
                (voice.name.includes('Google') || 
                 voice.name.includes('Microsoft') || 
                 voice.name.includes('native') ||
                 voice.name.includes('US') ||
                 voice.name.includes('UK'))
            );
            
            // Prefer US English voices
            this.voice = englishVoices.find(voice => voice.lang === 'en-US') ||
                        englishVoices.find(voice => voice.lang === 'en-GB') ||
                        englishVoices[0] ||
                        voices.find(voice => voice.lang.startsWith('en')) ||
                        voices[0];
                        
            console.log('Selected voice:', this.voice?.name, this.voice?.lang);
        };
        
        if (this.speechSynthesis.getVoices().length > 0) {
            setVoice();
        } else {
            this.speechSynthesis.addEventListener('voiceschanged', setVoice);
        }
    }
    
    bindEvents() {
        this.changeThemeBtn.addEventListener('click', () => this.showThemeSelector());
        this.nextBtn.addEventListener('click', () => this.nextWord());
        this.pronunciationBtn.addEventListener('click', () => this.pronounceWord());
        this.autoAdvanceToggle.addEventListener('change', (e) => {
            this.autoAdvanceEnabled = e.target.checked;
        });
        
        // Typing mode events
        this.typingModeToggle.addEventListener('change', (e) => {
            this.typingMode = e.target.checked;
            this.toggleTypingMode();
        });
        
        this.submitTypingBtn.addEventListener('click', () => this.submitTypingAnswer());
        
        this.typingInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                this.submitTypingAnswer();
            }
        });
        
        // Statistics dashboard events
        this.statsBtn.addEventListener('click', () => this.showStatsDashboard());
        this.closeStatsBtn.addEventListener('click', () => this.hideStatsDashboard());
        
        // Leaderboard button event
        if (this.leaderboardBtn) {
            this.leaderboardBtn.addEventListener('click', () => this.showLeaderboard());
        }
        
        // Social feature events
        this.shareStatsBtn.addEventListener('click', () => this.shareStats());
        this.challengeFriendsBtn.addEventListener('click', () => this.challengeFriends());
        this.copyLinkBtn.addEventListener('click', () => this.copyAppLink());
        
        // Leaderboard events
        if (this.saveToLeaderboardBtn) {
            this.saveToLeaderboardBtn.addEventListener('click', () => this.showNicknameModal());
        }
        
        if (this.saveNicknameBtn) {
            this.saveNicknameBtn.addEventListener('click', () => this.saveToLeaderboard());
        }
        
        if (this.cancelNicknameBtn) {
            this.cancelNicknameBtn.addEventListener('click', () => this.hideNicknameModal());
        }
        
        if (this.closeLeaderboardBtn) {
            this.closeLeaderboardBtn.addEventListener('click', () => this.hideLeaderboardModal());
        }
        
        // Choice selection
        this.choicesSection.addEventListener('click', (e) => {
            const choiceItem = e.target.closest('.choice-item');
            if (choiceItem && !choiceItem.classList.contains('correct') && !choiceItem.classList.contains('incorrect')) {
                this.selectChoice(parseInt(choiceItem.dataset.choice));
            }
        });
        
        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (this.mainContent.style.display !== 'none') {
                if (e.key >= '1' && e.key <= '4') {
                    const choiceIndex = parseInt(e.key) - 1;
                    this.selectChoice(choiceIndex);
                } else if (e.key === 'Enter' && this.nextBtn.style.display !== 'none') {
                    this.nextWord();
                }
            }
        });
    }
    
    showThemeSelector() {
        console.log('Showing theme selector...');
        this.themeSelector.style.display = 'block';
        this.mainContent.style.display = 'none';
        this.renderThemes();
    }
    
    renderThemes() {
        console.log('renderThemes called');
        console.log('themeGrid element:', this.themeGrid);
        
        if (!this.themeGrid) {
            console.error('themeGrid element not found');
            return;
        }
        
        this.themeGrid.innerHTML = '';
        
        try {
            Object.keys(vocabularyThemes).forEach(themeKey => {
                const theme = vocabularyThemes[themeKey];
                const themeProgress = this.userProgress.completedThemes[themeKey];
                const bestScore = this.userProgress.bestScores[themeKey] || 0;
                console.log(`Creating theme card for: ${themeKey}`, theme);
                
                const themeCard = document.createElement('button');
                themeCard.className = `theme-card ${themeKey}`;
                
                const wrongAnswersCount = Object.keys(this.userProgress.wrongAnswers[themeKey] || {}).length;
                
                let progressInfo = '';
                if (themeProgress && themeProgress.timesCompleted > 0) {
                    progressInfo = `
                        <div class="theme-progress">
                            <div class="best-score">ìµœê³ : ${bestScore}ì </div>
                            <div class="completion-count">${themeProgress.timesCompleted}íšŒ ì™„ì£¼</div>
                        </div>
                    `;
                }
                
                let reviewButton = '';
                if (wrongAnswersCount > 0) {
                    reviewButton = `
                        <button class="review-btn" data-theme="${themeKey}">
                            ë³µìŠµ (${wrongAnswersCount}ê°œ)
                        </button>
                    `;
                }
                
                themeCard.innerHTML = `
                    <span class="theme-icon">${theme.icon}</span>
                    <div class="theme-title">${theme.name}</div>
                    <div class="theme-count">${theme.words.length}ê°œ ë‹¨ì–´</div>
                    ${progressInfo}
                    ${reviewButton}
                `;
                
                themeCard.addEventListener('click', () => this.selectTheme(themeKey));
                
                // Add review button event listener if exists
                const reviewBtn = themeCard.querySelector('.review-btn');
                if (reviewBtn) {
                    reviewBtn.addEventListener('click', (event) => {
                        event.stopPropagation();
                        this.startReview(themeKey);
                    });
                }
                
                this.themeGrid.appendChild(themeCard);
                console.log(`Added theme card: ${themeKey}`);
            });
            
            console.log(`Total theme cards created: ${this.themeGrid.children.length}`);
            
            // Force layout refresh
            this.themeGrid.style.display = 'none';
            this.themeGrid.offsetHeight; // Trigger reflow
            this.themeGrid.style.display = 'grid';
            
        } catch (error) {
            console.error('Error in renderThemes:', error);
            this.themeGrid.innerHTML = '<div style="color: red; text-align: center; padding: 20px;">í…Œë§ˆ ë¡œë”© ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</div>';
        }
    }
    
    selectTheme(themeKey) {
        this.currentTheme = themeKey;
        this.usedIndices = [];
        this.totalQuestions = 0;
        this.correctAnswers = 0;
        
        // Reset session stats for new theme
        this.sessionStats = {
            wordsLearned: 0,
            correctAnswers: 0,
            totalAnswers: 0,
            startTime: Date.now(),
            questionStartTime: null,
            actualStudyTime: 0
        };
        
        this.currentThemeLabel.textContent = vocabularyThemes[themeKey].name;
        this.updateScore();
        
        this.themeSelector.style.display = 'none';
        this.mainContent.style.display = 'block';
        
        this.loadNewWord();
    }
    
    getRandomWordIndex() {
        const currentWords = vocabularyThemes[this.currentTheme].words;
        
        if (this.usedIndices.length >= currentWords.length) {
            // All words completed - show completion modal
            this.showCompletionModal();
            return null;
        }
        
        let randomIndex;
        do {
            randomIndex = Math.floor(Math.random() * currentWords.length);
        } while (this.usedIndices.includes(randomIndex));
        
        this.usedIndices.push(randomIndex);
        return randomIndex;
    }
    
    generateChoices(correctMeaning) {
        const currentWords = vocabularyThemes[this.currentTheme].words;
        const choices = [correctMeaning];
        
        // Get all possible meanings except the correct one
        const otherMeanings = currentWords
            .filter(word => word.meaning !== correctMeaning)
            .map(word => word.meaning);
        
        // Add random wrong choices
        while (choices.length < 4 && otherMeanings.length > 0) {
            const randomIndex = Math.floor(Math.random() * otherMeanings.length);
            const randomMeaning = otherMeanings[randomIndex];
            
            if (!choices.includes(randomMeaning)) {
                choices.push(randomMeaning);
            }
            otherMeanings.splice(randomIndex, 1);
        }
        
        // If we don't have enough choices from current theme, add from other themes
        if (choices.length < 4) {
            const allOtherMeanings = [];
            Object.keys(vocabularyThemes).forEach(themeKey => {
                if (themeKey !== this.currentTheme) {
                    vocabularyThemes[themeKey].words.forEach(word => {
                        if (!choices.includes(word.meaning)) {
                            allOtherMeanings.push(word.meaning);
                        }
                    });
                }
            });
            
            while (choices.length < 4 && allOtherMeanings.length > 0) {
                const randomIndex = Math.floor(Math.random() * allOtherMeanings.length);
                choices.push(allOtherMeanings[randomIndex]);
                allOtherMeanings.splice(randomIndex, 1);
            }
        }
        
        // Shuffle choices
        const shuffledChoices = [...choices];
        for (let i = shuffledChoices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffledChoices[i], shuffledChoices[j]] = [shuffledChoices[j], shuffledChoices[i]];
        }
        
        return {
            choices: shuffledChoices,
            correctIndex: shuffledChoices.indexOf(correctMeaning)
        };
    }
    
    loadNewWord() {
        this.currentWordIndex = this.getRandomWordIndex();
        
        if (this.currentWordIndex === null) {
            // Theme completed
            this.showCompletionModal();
            return;
        }
        
        const currentWord = vocabularyThemes[this.currentTheme].words[this.currentWordIndex];
        
        this.wordElement.textContent = currentWord.word;
        this.wordTypeElement.textContent = currentWord.type;
        
        // Generate choices
        const choiceData = this.generateChoices(currentWord.meaning);
        this.currentChoices = choiceData.choices;
        this.correctChoiceIndex = choiceData.correctIndex;
        this.selectedChoice = null;
        
        // Update choice elements
        for (let i = 0; i < 4; i++) {
            const choiceElement = document.getElementById(`choice${i}`);
            const choiceItem = choiceElement.parentElement;
            
            choiceElement.textContent = this.currentChoices[i] || '';
            choiceItem.className = 'choice-item';
            // Remove all selection/result classes
            choiceItem.classList.remove('correct', 'incorrect', 'selected');
        }
        
        this.feedbackElement.textContent = '';
        this.feedbackElement.className = 'feedback';
        this.nextBtn.style.display = 'none';
        
        // Reset typing mode state for loadNewWord
        if (this.typingMode) {
            this.typingInput.value = '';
            this.typingInput.disabled = false;
            this.submitTypingBtn.disabled = false;
            this.typingInput.style.borderColor = '';
            this.typingInput.focus();
        }
        
        // Update question progress counter
        this.updateQuestionProgress();
        this.updateQuizProgress();
        
        // Record question start time for accurate study time tracking
        this.sessionStats.questionStartTime = Date.now();
    }
    
    updateQuestionProgress() {
        if (this.questionProgress) {
            const currentQuestion = this.totalQuestions + 1;
            const totalQuestions = this.reviewMode ? this.reviewWords.length : vocabularyThemes[this.currentTheme].words.length;
            this.questionProgress.textContent = `ë¬¸ì œ ${currentQuestion}/${totalQuestions}`;
        }
    }
    
    selectChoice(choiceIndex) {
        if (this.selectedChoice !== null) return;
        
        this.selectedChoice = choiceIndex;
        this.totalQuestions++;
        
        // Record actual study time for this question
        if (this.sessionStats.questionStartTime) {
            const questionTime = Date.now() - this.sessionStats.questionStartTime;
            this.sessionStats.actualStudyTime += questionTime;
        }
        
        // Show results
        for (let i = 0; i < 4; i++) {
            const choiceItem = document.querySelector(`[data-choice="${i}"]`);
            
            if (i === this.correctChoiceIndex) {
                choiceItem.classList.add('correct');
            } else if (i === choiceIndex) {
                choiceItem.classList.add('incorrect');
            }
        }
        
        const isCorrect = choiceIndex === this.correctChoiceIndex;
        
        if (isCorrect) {
            this.correctAnswers++;
            this.showFeedback('ì •ë‹µì…ë‹ˆë‹¤! ğŸ‰', 'correct');
        } else {
            // Track wrong answer for review
            this.trackWrongAnswer();
            this.showFeedback(`í‹€ë ¸ìŠµë‹ˆë‹¤. ğŸ˜” ì •ë‹µ: ${this.currentChoices[this.correctChoiceIndex]}`, 'incorrect');
        }
        
        this.updateScore();
        this.nextBtn.style.display = 'inline-block';
        
        // Auto advance after 2 seconds if enabled
        if (this.autoAdvanceEnabled) {
            this.autoAdvanceTimeout = setTimeout(() => {
                this.nextWord();
            }, 2000);
        }
    }
    
    showFeedback(message, type) {
        this.feedbackElement.textContent = message;
        this.feedbackElement.className = `feedback ${type}`;
    }
    
    toggleTypingMode() {
        if (this.typingMode) {
            this.choicesSection.style.display = 'none';
            this.typingSection.style.display = 'block';
            this.typingInput.focus();
        } else {
            this.choicesSection.style.display = 'block';
            this.typingSection.style.display = 'none';
        }
        
        // Reset current question state when switching modes
        if (this.currentTheme) {
            this.resetCurrentQuestion();
        }
    }
    
    resetCurrentQuestion() {
        this.selectedChoice = null;
        this.typingInput.value = '';
        this.feedbackElement.textContent = '';
        this.feedbackElement.className = 'feedback';
        this.nextBtn.style.display = 'none';
        
        // Clear choice selections if in choice mode
        if (!this.typingMode) {
            for (let i = 0; i < 4; i++) {
                const choiceItem = document.querySelector(`[data-choice="${i}"]`);
                if (choiceItem) {
                    choiceItem.classList.remove('correct', 'incorrect', 'selected');
                }
            }
        }
    }
    
    submitTypingAnswer() {
        if (this.selectedChoice !== null) return;
        
        const userAnswer = this.typingInput.value.trim().toLowerCase();
        if (!userAnswer) {
            this.showFeedback('ë‹µì•ˆì„ ì…ë ¥í•´ì£¼ì„¸ìš”.', 'incorrect');
            return;
        }
        
        this.selectedChoice = 0; // Mark as answered
        this.totalQuestions++;
        
        // Record actual study time for this question
        if (this.sessionStats.questionStartTime) {
            const questionTime = Date.now() - this.sessionStats.questionStartTime;
            this.sessionStats.actualStudyTime += questionTime;
        }
        
        // Get the correct answer
        const correctAnswer = this.reviewMode ? 
            this.reviewWords[this.currentWordIndex].meaning : 
            vocabularyThemes[this.currentTheme].words[this.currentWordIndex].meaning;
        
        // Check if answer is correct (allow for variations)
        const isCorrect = this.checkTypingAnswer(userAnswer, correctAnswer);
        
        if (isCorrect) {
            this.correctAnswers++;
            this.showFeedback('ì •ë‹µì…ë‹ˆë‹¤! ğŸ‰', 'correct');
            this.typingInput.style.borderColor = 'var(--correct-color)';
        } else {
            // Track wrong answer for review
            this.trackWrongAnswer();
            this.showFeedback(`í‹€ë ¸ìŠµë‹ˆë‹¤. ğŸ˜” ì •ë‹µ: ${correctAnswer}`, 'incorrect');
            this.typingInput.style.borderColor = 'var(--incorrect-color)';
        }
        
        this.updateScore();
        this.nextBtn.style.display = 'inline-block';
        
        // Disable input after submission
        this.typingInput.disabled = true;
        this.submitTypingBtn.disabled = true;
        
        // Auto advance after 2 seconds if enabled
        if (this.autoAdvanceEnabled) {
            this.autoAdvanceTimeout = setTimeout(() => {
                this.nextWord();
            }, 2000);
        }
    }
    
    checkTypingAnswer(userAnswer, correctAnswer) {
        // Normalize both answers for comparison
        const normalizeAnswer = (answer) => {
            return answer.toLowerCase()
                .trim()
                .replace(/[.,;:!?'"()]/g, '') // Remove punctuation
                .replace(/\s+/g, ' '); // Normalize spaces
        };
        
        const normalizedUser = normalizeAnswer(userAnswer);
        const normalizedCorrect = normalizeAnswer(correctAnswer);
        
        // Exact match
        if (normalizedUser === normalizedCorrect) {
            return true;
        }
        
        // Check if user answer contains the key words (for multi-word meanings)
        const correctWords = normalizedCorrect.split(' ');
        if (correctWords.length > 1) {
            // For multi-word answers, check if user got at least 80% of the words right
            const userWords = normalizedUser.split(' ');
            const matches = correctWords.filter(word => 
                userWords.some(userWord => 
                    userWord.includes(word) || word.includes(userWord)
                )
            );
            return matches.length >= Math.ceil(correctWords.length * 0.8);
        }
        
        // For single words, allow partial matches if the word is long enough
        if (normalizedCorrect.length >= 3) {
            return normalizedUser.includes(normalizedCorrect) || normalizedCorrect.includes(normalizedUser);
        }
        
        return false;
    }
    
    nextWord() {
        // Clear any pending auto-advance timeout
        if (this.autoAdvanceTimeout) {
            clearTimeout(this.autoAdvanceTimeout);
            this.autoAdvanceTimeout = null;
        }
        
        if (this.reviewMode) {
            this.loadReviewWord();
        } else {
            this.loadNewWord();
        }
    }
    
    pronounceWord() {
        if (this.speechSynthesis && this.voice) {
            // Cancel any ongoing speech
            this.speechSynthesis.cancel();
            
            // Get the word currently displayed on screen (works for both normal and review mode)
            const word = this.wordElement.textContent;
            const utterance = new SpeechSynthesisUtterance(word);
            
            utterance.voice = this.voice;
            utterance.rate = 0.7; // Slower for clarity
            utterance.pitch = 1;
            utterance.volume = 1;
            utterance.lang = 'en-US'; // Force English US
            
            console.log(`Pronouncing: ${word} with voice: ${this.voice.name}`);
            this.speechSynthesis.speak(utterance);
        } else {
            console.warn('Speech synthesis not available or voice not set');
        }
    }
    
    updateScore() {
        // Calculate total questions in current quiz (theme or review)
        const totalQuestionsInQuiz = this.reviewMode ? this.reviewWords.length : vocabularyThemes[this.currentTheme].words.length;
        
        // Calculate score as percentage of correct answers (100 points max)
        const score = this.totalQuestions > 0 ? Math.round((this.correctAnswers / this.totalQuestions) * 100) : 0;
        this.scoreElement.textContent = score;
        // Display accuracy as correct/total format
        this.accuracyElement.textContent = `${this.correctAnswers}/${totalQuestionsInQuiz}`;
    }
    
    updateQuizProgress() {
        const currentWords = vocabularyThemes[this.currentTheme].words;
        const progress = (this.usedIndices.length / currentWords.length) * 100;
        this.progressFill.style.width = `${progress}%`;
    }
    
    showCompletionModal() {
        const modal = document.getElementById('completionModal');
        const finalScore = document.getElementById('finalScore');
        const finalAccuracy = document.getElementById('finalAccuracy');
        const completedTheme = document.getElementById('completedTheme');
        const nextThemeBtn = document.getElementById('nextThemeBtn');
        const retryThemeBtn = document.getElementById('retryThemeBtn');
        
        // Update modal content
        const finalScoreValue = this.totalQuestions > 0 ? Math.round((this.correctAnswers / this.totalQuestions) * 100) : 0;
        const accuracy = finalScoreValue; // accuracy as percentage for shareScore function
        finalScore.textContent = finalScoreValue;
        finalAccuracy.textContent = `${this.correctAnswers}/${this.totalQuestions}`;
        completedTheme.textContent = vocabularyThemes[this.currentTheme].name;
        
        // Check for challenge completion
        if (this.checkChallengeSuccess(finalScoreValue)) {
            return; // Challenge result modal will be shown instead
        }
        
        // Update user progress
        this.updateProgress(this.currentTheme, finalScoreValue, accuracy);
        
        // Show modal
        modal.style.display = 'flex';
        
        // Bind events
        nextThemeBtn.onclick = () => {
            modal.style.display = 'none';
            this.showThemeSelector();
        };
        
        retryThemeBtn.onclick = () => {
            modal.style.display = 'none';
            this.selectTheme(this.currentTheme);
        };
        
        this.shareScoreBtn.onclick = () => {
            // ì‹¤ì œ ì •ë‹µ ê°œìˆ˜/ì´ ë¬¸ì œ ìˆ˜ í˜•ì‹ìœ¼ë¡œ ì „ë‹¬
            const accuracyText = `${this.correctAnswers}/${this.totalQuestions}`;
            this.shareScore(finalScoreValue, accuracyText, vocabularyThemes[this.currentTheme].name);
        };
        
        // ë¦¬ë”ë³´ë“œ ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€ (ì „ì²´ 40ë¬¸ì œ ì™„ë£Œ ì‹œì—ë§Œ í‘œì‹œ)
        const saveToLeaderboardBtn = document.getElementById('saveToLeaderboardBtn');
        if (saveToLeaderboardBtn) {
            if (this.totalQuestions === 40) {
                saveToLeaderboardBtn.style.display = 'inline-block';
            } else {
                saveToLeaderboardBtn.style.display = 'none';
            }
        }
        
        // Close modal on background click
        modal.onclick = (e) => {
            if (e.target === modal) {
                modal.style.display = 'none';
                this.showThemeSelector();
            }
        };
    }
    
    // Leaderboard Management Methods
    async initializeLeaderboard() {
        console.log('Initializing leaderboard...');
        if (window.leaderboardManager) {
            console.log('LeaderboardManager found, initializing...');
            await window.leaderboardManager.initialize();
            this.updateConnectionStatus();
        } else {
            console.warn('LeaderboardManager not found');
        }
    }
    
    updateConnectionStatus() {
        // Update both connection status elements
        const connectionElements = [
            document.getElementById('connectionStatus'), // Nickname modal
            document.getElementById('leaderboardConnectionInfo') // Leaderboard modal
        ];
        
        const isOnline = window.leaderboardManager?.isConnected();
        
        connectionElements.forEach((element, index) => {
            if (!element) return;
            
            const statusDot = element.querySelector('.status-dot');
            const statusText = element.querySelector('.status-text');
            
            if (isOnline) {
                if (statusDot) statusDot.className = 'status-dot online';
                if (statusText) statusText.textContent = 'ì˜¨ë¼ì¸ ëª¨ë“œ';
            } else {
                if (statusDot) statusDot.className = 'status-dot offline';
                if (statusText) statusText.textContent = 'ì˜¤í”„ë¼ì¸ ëª¨ë“œ';
            }
        });
    }
    
    showNicknameModal() {
        console.log('showNicknameModal called');
        
        if (!this.nicknameModal) {
            console.warn('nicknameModal element not found');
            return;
        }
        
        // Update connection status
        this.updateConnectionStatus();
        
        // Check if user already has a nickname
        const currentUser = window.leaderboardManager?.getCurrentUser();
        if (currentUser) {
            this.nicknameInput.value = currentUser.nickname;
        }
        
        console.log('Showing nickname modal');
        this.nicknameModal.style.display = 'flex';
        
        if (this.nicknameInput) {
            this.nicknameInput.focus();
            
            // Enter key to save
            this.nicknameInput.onkeypress = (e) => {
                if (e.key === 'Enter') {
                    this.saveToLeaderboard();
                }
            };
        }
        
        // Add background click to close modal
        this.nicknameModal.onclick = (e) => {
            if (e.target === this.nicknameModal) {
                this.hideNicknameModal();
            }
        };
    }
    
    hideNicknameModal() {
        if (this.nicknameModal) {
            this.nicknameModal.style.display = 'none';
            this.nicknameInput.value = '';
            this.updateConnectionStatus();
        }
    }
    
    async saveToLeaderboard() {
        console.log('saveToLeaderboard function called!');
        
        if (!this.nicknameInput) {
            alert('ë‹‰ë„¤ì„ ì…ë ¥ í•„ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            return;
        }
        
        const nickname = this.nicknameInput.value.trim();
        
        if (!nickname || nickname.length < 2) {
            alert('ë‹‰ë„¤ì„ì€ 2ì ì´ìƒ ì…ë ¥í•´ì£¼ì„¸ìš”.');
            return;
        }

        if (nickname.length > 10) {
            alert('ë‹‰ë„¤ì„ì€ 10ì ì´í•˜ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.');
            return;
        }

        if (!window.leaderboardManager) {
            alert('ë¦¬ë”ë³´ë“œ ì‹œìŠ¤í…œì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
            return;
        }
        
        try {
            // Set user nickname
            window.leaderboardManager.setUser(nickname);
            
            // Prepare score data from current quiz results
            const finalScore = document.getElementById('finalScore')?.textContent || '0';
            const finalAccuracyText = document.getElementById('finalAccuracy')?.textContent || '0/40';
            // Parse "10/40" format to get percentage
            const [correct, total] = finalAccuracyText.split('/').map(num => parseInt(num) || 0);
            const finalAccuracy = total > 0 ? Math.round((correct / total) * 100) : 0;
            
            console.log('Score data preparation:', {
                finalScore,
                finalAccuracyText,
                finalAccuracy,
                theme: this.currentTheme
            });
            
            const scoreData = {
                score: parseInt(finalScore),
                accuracy: finalAccuracy,
                theme: this.currentTheme,
                studyTime: this.sessionStats.actualStudyTime || 0
            };
            
            // Save to leaderboard with timeout
            const savePromise = window.leaderboardManager.saveScore(scoreData);
            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Timeout')), 5000)
            );
            
            const result = await Promise.race([savePromise, timeoutPromise]);
            
            this.hideNicknameModal();
            
            if (result.success) {
                if (result.online) {
                    alert('ğŸ‰ ì ìˆ˜ê°€ ì˜¨ë¼ì¸ ë¦¬ë”ë³´ë“œì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
                } else {
                    alert('âœ… ì ìˆ˜ê°€ ë¡œì»¬ì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
                }
                this.showLeaderboardModal();
            } else {
                alert('ì ìˆ˜ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        } catch (error) {
            console.error('Error saving to leaderboard:', error);
            this.hideNicknameModal();
            alert('ì ìˆ˜ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
    }
    
    // Leaderboard display method
    async showLeaderboard() {
        console.log('showLeaderboard called');
        
        // Initialize leaderboard manager if needed
        if (!window.leaderboardManager) {
            console.warn('Leaderboard manager not initialized');
            this.showToast('ë¦¬ë”ë³´ë“œ ì‹œìŠ¤í…œì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
            return;
        }
        
        try {
            // Initialize Firebase connection
            console.log('Initializing Firebase connection...');
            const isOnline = await window.leaderboardManager.initialize();
            console.log('Firebase initialization result:', isOnline);
            console.log('isConnected check:', window.leaderboardManager.isConnected());
            
            // Show leaderboard modal directly
            this.showLeaderboardModal();
        } catch (error) {
            console.error('Error showing leaderboard:', error);
            this.showToast('ë¦¬ë”ë³´ë“œë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
    }
    
    showLeaderboardModal() {
        if (this.leaderboardModal) {
            this.leaderboardModal.style.display = 'flex';
            this.initializeLeaderboardTabs();
            this.loadLeaderboardData();
        }
    }
    
    initializeLeaderboardTabs() {
        // Tab button event listeners
        const tabButtons = this.leaderboardModal.querySelectorAll('.tab-btn');
        const tabContents = this.leaderboardModal.querySelectorAll('.tab-content');
        
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const targetTab = button.getAttribute('data-tab');
                
                // Update active tab button
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                
                // Update active tab content
                tabContents.forEach(content => content.classList.remove('active'));
                const targetContent = this.leaderboardModal.querySelector(`#${targetTab}Tab`);
                if (targetContent) {
                    targetContent.classList.add('active');
                }
                
                // Load appropriate data
                if (targetTab === 'global') {
                    this.loadLeaderboardData();
                } else if (targetTab === 'personal') {
                    this.loadPersonalStats();
                }
            });
        });
    }
    
    hideLeaderboardModal() {
        if (this.leaderboardModal) {
            this.leaderboardModal.style.display = 'none';
        }
    }
    
    async loadLeaderboardData() {
        try {
            const leaderboard = await window.leaderboardManager.getLeaderboard(10);
            this.displayLeaderboard(leaderboard);
        } catch (error) {
            console.error('Failed to load leaderboard:', error);
        }
    }
    
    loadPersonalStats() {
        const personalStatsDiv = document.getElementById('personalStats');
        if (!personalStatsDiv) {
            console.error('personalStats element not found');
            return;
        }
        
        console.log('Loading personal stats...');
        
        const currentUser = window.leaderboardManager?.getCurrentUser();
        if (!currentUser) {
            personalStatsDiv.innerHTML = '<div class="loading">ë‹‰ë„¤ì„ì„ ì„¤ì •í•´ì£¼ì„¸ìš”.</div>';
            return;
        }
        
        console.log('Current user:', currentUser);
        console.log('User progress:', this.userProgress);
        console.log('User progress details:', {
            completedThemes: this.userProgress.completedThemes,
            bestScores: this.userProgress.bestScores,
            totalWordsLearned: this.userProgress.totalWordsLearned
        });
        console.log('completedThemes keys:', Object.keys(this.userProgress.completedThemes || {}));
        console.log('bestScores keys:', Object.keys(this.userProgress.bestScores || {}));
        
        // Get local user progress data
        const userProgress = this.userProgress || {};
        
        // Calculate personal statistics with safe defaults
        const totalThemes = Object.keys(vocabularyThemes || {}).length;
        const completedThemes = Object.keys(userProgress.completedThemes || {}).length;
        const totalGames = Object.values(userProgress.completedThemes || {})
            .reduce((sum, theme) => sum + (theme.timesCompleted || 0), 0);
        
        const bestScores = Object.values(userProgress.bestScores || {});
        const averageScore = bestScores.length > 0 
            ? bestScores.reduce((sum, score) => sum + score, 0) / bestScores.length 
            : 0;
        
        console.log('Calculated stats:', {
            totalThemes,
            completedThemes,
            totalGames,
            averageScore
        });
        
        personalStatsDiv.innerHTML = `
            <div class="personal-stat-item">
                <span class="personal-stat-label">ë‹‰ë„¤ì„</span>
                <span class="personal-stat-value">${currentUser.nickname}</span>
            </div>
            <div class="personal-stat-item">
                <span class="personal-stat-label">ì™„ë£Œí•œ í…Œë§ˆ</span>
                <span class="personal-stat-value">${completedThemes}/${totalThemes}</span>
            </div>
            <div class="personal-stat-item">
                <span class="personal-stat-label">ì´ ê²Œì„ ìˆ˜</span>
                <span class="personal-stat-value">${totalGames}íšŒ</span>
            </div>
            <div class="personal-stat-item">
                <span class="personal-stat-label">í‰ê·  ì ìˆ˜</span>
                <span class="personal-stat-value">${Math.round(averageScore)}ì </span>
            </div>
            <div class="personal-stat-item">
                <span class="personal-stat-label">í•™ìŠµí•œ ë‹¨ì–´</span>
                <span class="personal-stat-value">${userProgress.totalWordsLearned || 0}ê°œ</span>
            </div>
            <div class="personal-stat-item">
                <span class="personal-stat-label">ì—°ì† í•™ìŠµì¼</span>
                <span class="personal-stat-value">${userProgress.currentStreak || 0}ì¼</span>
            </div>
        `;
        
        console.log('Personal stats loaded successfully');
    }
    
    displayLeaderboard(leaderboard) {
        const globalLeaderboard = document.getElementById('globalLeaderboard');
        if (!globalLeaderboard) return;
        
        if (leaderboard.length === 0) {
            globalLeaderboard.innerHTML = '<div class="loading">ì•„ì§ ë“±ë¡ëœ ì ìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
            return;
        }
        
        globalLeaderboard.innerHTML = leaderboard.map((entry, index) => {
            const rank = index + 1;
            const rankClass = rank === 1 ? 'gold' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : '';
            
            // ê°€ì¥ ìµœê·¼ì— í”Œë ˆì´í•œ í…Œë§ˆ ì°¾ê¸°
            let recentTheme = 'í…Œë§ˆ';
            let correctAnswers = 0;
            let totalQuestions = 40; // ê° í…Œë§ˆë‹¹ 40ë¬¸ì œ
            
            if (entry.themes) {
                const themeEntries = Object.entries(entry.themes);
                if (themeEntries.length > 0) {
                    // ê°€ì¥ ë†’ì€ ì ìˆ˜ë¥¼ ë°›ì€ í…Œë§ˆ ì°¾ê¸°
                    const bestThemeEntry = themeEntries.reduce((best, current) => {
                        return current[1].bestScore > (best[1].bestScore || 0) ? current : best;
                    });
                    
                    // í…Œë§ˆ ì´ë¦„ì„ í•œê¸€ë¡œ ë³€í™˜
                    const themeNames = {
                        'business': 'ë¹„ì¦ˆë‹ˆìŠ¤',
                        'science': 'ê³¼í•™ê¸°ìˆ ', 
                        'travel': 'ì—¬í–‰êµí†µ',
                        'daily': 'ì¼ìƒìƒí™œ',
                        'academic': 'í•™ë¬¸êµìœ¡',
                        'it': 'ITì»´í“¨í„°'
                    };
                    
                    recentTheme = themeNames[bestThemeEntry[0]] || bestThemeEntry[0];
                    
                    // ì •ë‹µë¥ ë¡œë¶€í„° ì •ë‹µ ê°œìˆ˜ ê³„ì‚° (100ì  ë§Œì  = 40ë¬¸ì œ ì „ë¶€ ì •ë‹µ)
                    const accuracy = bestThemeEntry[1].lastAccuracy || entry.averageAccuracy || 0;
                    correctAnswers = Math.round((accuracy / 100) * totalQuestions);
                }
            } else {
                // themes ì •ë³´ê°€ ì—†ëŠ” ê²½ìš° í‰ê·  ì •ë‹µë¥  ì‚¬ìš©
                const accuracy = entry.averageAccuracy || 0;
                correctAnswers = Math.round((accuracy / 100) * totalQuestions);
            }
            
            // í”Œë ˆì´ ì‹œê°„ í¬ë§·
            const playTime = this.formatDateToKorean(entry.lastPlayed);
            
            return `
                <div class="leaderboard-item">
                    <div class="leaderboard-rank ${rankClass}">${rank}</div>
                    <div class="leaderboard-info">
                        <div class="leaderboard-nickname">${entry.nickname}</div>
                        <div class="leaderboard-stats">${recentTheme} â€¢ ${correctAnswers}/${totalQuestions} â€¢ ${playTime}</div>
                    </div>
                    <div class="leaderboard-score">${entry.bestScore}ì </div>
                </div>
            `;
        }).join('');
    }
}

// Global quiz instance for review functionality
let quiz;

// Ensure the app initializes even if there are timing issues
let initAttempts = 0;
const maxInitAttempts = 3;

function initializeApp() {
    console.log(`DOM loaded, starting VocabularyQuiz... (attempt ${initAttempts + 1})`);
    
    try {
        // Check if critical elements exist
        const themeGrid = document.getElementById('themeGrid');
        const themeSelector = document.getElementById('themeSelector');
        const mainContent = document.getElementById('mainContent');
        
        if (!themeGrid || !themeSelector || !mainContent) {
            console.warn('Critical elements not found, retrying...');
            initAttempts++;
            if (initAttempts < maxInitAttempts) {
                setTimeout(initializeApp, 100);
                return;
            } else {
                throw new Error('Critical DOM elements not found after multiple attempts');
            }
        }
        
        window.quiz = new VocabularyQuiz();
        console.log('VocabularyQuiz initialized successfully');
    } catch (error) {
        console.error('Error initializing VocabularyQuiz:', error);
        console.error('Error stack:', error.stack);
        
        // Fallback: create a basic error display and manual theme buttons
        const themeGrid = document.getElementById('themeGrid');
        if (themeGrid) {
            themeGrid.innerHTML = `
                <div style="color: red; text-align: center; padding: 20px; grid-column: 1/-1;">
                    ë¡œë”© ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. 
                    <br><small>ì˜¤ë¥˜: ${error.message}</small>
                    <br><br>
                    <button onclick="location.reload()" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer;">
                        ìƒˆë¡œê³ ì¹¨
                    </button>
                </div>
            `;
        }
    }
}

// Dark mode functionality
class ThemeManager {
    constructor() {
        this.initializeTheme();
        this.setupEventListeners();
    }
    
    initializeTheme() {
        // Check for saved theme preference or default to light mode
        const savedTheme = localStorage.getItem('theme') || 'light';
        this.setTheme(savedTheme);
    }
    
    setupEventListeners() {
        const themeToggle = document.getElementById('themeToggle');
        if (themeToggle) {
            themeToggle.addEventListener('click', () => this.toggleTheme());
            console.log('Theme toggle event listener added successfully');
        } else {
            console.warn('Theme toggle button not found');
            // Try again after a short delay
            setTimeout(() => {
                const themeToggle = document.getElementById('themeToggle');
                if (themeToggle) {
                    themeToggle.addEventListener('click', () => this.toggleTheme());
                    console.log('Theme toggle event listener added successfully (delayed)');
                } else {
                    console.error('Theme toggle button still not found after delay');
                }
            }, 100);
        }
    }
    
    setTheme(theme) {
        const body = document.body;
        const themeIcon = document.querySelector('.theme-icon');
        
        console.log('Setting theme to:', theme);
        
        if (theme === 'dark') {
            body.setAttribute('data-theme', 'dark');
            if (themeIcon) {
                themeIcon.textContent = 'â˜€ï¸';
                console.log('Set icon to sun (dark mode)');
            } else {
                console.warn('Theme icon not found for dark mode');
            }
        } else {
            body.removeAttribute('data-theme');
            if (themeIcon) {
                themeIcon.textContent = 'ğŸŒ™';
                console.log('Set icon to moon (light mode)');
            } else {
                console.warn('Theme icon not found for light mode');
            }
        }
        
        // Save theme preference
        localStorage.setItem('theme', theme);
        console.log('Theme saved to localStorage:', theme);
    }
    
    toggleTheme() {
        const currentTheme = document.body.getAttribute('data-theme');
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        console.log('Toggling theme from', currentTheme || 'light', 'to', newTheme);
        this.setTheme(newTheme);
    }
    
    getCurrentTheme() {
        return document.body.getAttribute('data-theme') || 'light';
    }
}

// Initialize theme manager
let themeManager;

function initializeThemeManager() {
    console.log('Initializing ThemeManager...');
    themeManager = new ThemeManager();
    console.log('ThemeManager initialized successfully');
}

function initializeComplete() {
    initializeThemeManager();
    initializeApp();
}

document.addEventListener('DOMContentLoaded', initializeComplete);

// Backup initialization for older browsers
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeComplete);
} else {
    // DOM is already loaded
    setTimeout(initializeComplete, 10);
}