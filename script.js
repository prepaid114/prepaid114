const vocabularyThemes = {
    business: {
        name: "ë¹„ì¦ˆë‹ˆìŠ¤ ì˜ì–´",
        icon: "ğŸ’¼",
        words: [
            { word: "achieve", meaning: "ë‹¬ì„±í•˜ë‹¤", type: "ë™ì‚¬" },
            { word: "acquire", meaning: "íšë“í•˜ë‹¤", type: "ë™ì‚¬" },
            { word: "agreement", meaning: "í•©ì˜, ê³„ì•½", type: "ëª…ì‚¬" },
            { word: "budget", meaning: "ì˜ˆì‚°", type: "ëª…ì‚¬" },
            { word: "colleague", meaning: "ë™ë£Œ", type: "ëª…ì‚¬" },
            { word: "conference", meaning: "íšŒì˜", type: "ëª…ì‚¬" },
            { word: "deadline", meaning: "ë§ˆê°ì¼", type: "ëª…ì‚¬" },
            { word: "department", meaning: "ë¶€ì„œ", type: "ëª…ì‚¬" },
            { word: "efficient", meaning: "íš¨ìœ¨ì ì¸", type: "í˜•ìš©ì‚¬" },
            { word: "evaluate", meaning: "í‰ê°€í•˜ë‹¤", type: "ë™ì‚¬" },
            { word: "executive", meaning: "ì„ì›", type: "ëª…ì‚¬" },
            { word: "financial", meaning: "ì¬ì •ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "investment", meaning: "íˆ¬ì", type: "ëª…ì‚¬" },
            { word: "management", meaning: "ê´€ë¦¬", type: "ëª…ì‚¬" },
            { word: "negotiate", meaning: "í˜‘ìƒí•˜ë‹¤", type: "ë™ì‚¬" },
            { word: "opportunity", meaning: "ê¸°íšŒ", type: "ëª…ì‚¬" },
            { word: "profit", meaning: "ì´ìµ", type: "ëª…ì‚¬" },
            { word: "proposal", meaning: "ì œì•ˆì„œ", type: "ëª…ì‚¬" },
            { word: "strategy", meaning: "ì „ëµ", type: "ëª…ì‚¬" },
            { word: "supervisor", meaning: "ìƒì‚¬", type: "ëª…ì‚¬" },
            { word: "analysis", meaning: "ë¶„ì„", type: "ëª…ì‚¬" },
            { word: "corporate", meaning: "ê¸°ì—…ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "customer", meaning: "ê³ ê°", type: "ëª…ì‚¬" },
            { word: "develop", meaning: "ê°œë°œí•˜ë‹¤", type: "ë™ì‚¬" },
            { word: "economy", meaning: "ê²½ì œ", type: "ëª…ì‚¬" },
            { word: "entrepreneur", meaning: "ê¸°ì—…ê°€", type: "ëª…ì‚¬" },
            { word: "market", meaning: "ì‹œì¥", type: "ëª…ì‚¬" },
            { word: "productivity", meaning: "ìƒì‚°ì„±", type: "ëª…ì‚¬" },
            { word: "revenue", meaning: "ìˆ˜ìµ", type: "ëª…ì‚¬" },
            { word: "stakeholder", meaning: "ì´í•´ê´€ê³„ì", type: "ëª…ì‚¬" },
            { word: "consultant", meaning: "ì»¨ì„¤í„´íŠ¸", type: "ëª…ì‚¬" },
            { word: "franchise", meaning: "í”„ëœì°¨ì´ì¦ˆ", type: "ëª…ì‚¬" },
            { word: "innovation", meaning: "í˜ì‹ ", type: "ëª…ì‚¬" },
            { word: "partnership", meaning: "íŒŒíŠ¸ë„ˆì‹­", type: "ëª…ì‚¬" },
            { word: "quarterly", meaning: "ë¶„ê¸°ë³„", type: "í˜•ìš©ì‚¬" },
            { word: "sustainability", meaning: "ì§€ì†ê°€ëŠ¥ì„±", type: "ëª…ì‚¬" },
            { word: "transaction", meaning: "ê±°ë˜", type: "ëª…ì‚¬" },
            { word: "workflow", meaning: "ì—…ë¬´íë¦„", type: "ëª…ì‚¬" },
            { word: "benchmark", meaning: "ê¸°ì¤€ì ", type: "ëª…ì‚¬" },
            { word: "compliance", meaning: "ì¤€ìˆ˜", type: "ëª…ì‚¬" }
        ]
    },
    science: {
        name: "ê³¼í•™ ê¸°ìˆ ",
        icon: "ğŸ”¬",
        words: [
            { word: "analyze", meaning: "ë¶„ì„í•˜ë‹¤", type: "ë™ì‚¬" },
            { word: "atmosphere", meaning: "ëŒ€ê¸°", type: "ëª…ì‚¬" },
            { word: "biology", meaning: "ìƒë¬¼í•™", type: "ëª…ì‚¬" },
            { word: "chemistry", meaning: "í™”í•™", type: "ëª…ì‚¬" },
            { word: "data", meaning: "ë°ì´í„°", type: "ëª…ì‚¬" },
            { word: "evolution", meaning: "ì§„í™”", type: "ëª…ì‚¬" },
            { word: "experiment", meaning: "ì‹¤í—˜", type: "ëª…ì‚¬" },
            { word: "formula", meaning: "ê³µì‹", type: "ëª…ì‚¬" },
            { word: "genetics", meaning: "ìœ ì „í•™", type: "ëª…ì‚¬" },
            { word: "hypothesis", meaning: "ê°€ì„¤", type: "ëª…ì‚¬" },
            { word: "laboratory", meaning: "ì‹¤í—˜ì‹¤", type: "ëª…ì‚¬" },
            { word: "molecule", meaning: "ë¶„ì", type: "ëª…ì‚¬" },
            { word: "observation", meaning: "ê´€ì°°", type: "ëª…ì‚¬" },
            { word: "physics", meaning: "ë¬¼ë¦¬í•™", type: "ëª…ì‚¬" },
            { word: "research", meaning: "ì—°êµ¬", type: "ëª…ì‚¬" },
            { word: "scientific", meaning: "ê³¼í•™ì ì¸", type: "í˜•ìš©ì‚¬" },
            { word: "technology", meaning: "ê¸°ìˆ ", type: "ëª…ì‚¬" },
            { word: "theory", meaning: "ì´ë¡ ", type: "ëª…ì‚¬" },
            { word: "universe", meaning: "ìš°ì£¼", type: "ëª…ì‚¬" },
            { word: "variable", meaning: "ë³€ìˆ˜", type: "ëª…ì‚¬" },
            { word: "algorithm", meaning: "ì•Œê³ ë¦¬ì¦˜", type: "ëª…ì‚¬" },
            { word: "bacteria", meaning: "ë°•í…Œë¦¬ì•„", type: "ëª…ì‚¬" },
            { word: "catalyst", meaning: "ì´‰ë§¤", type: "ëª…ì‚¬" },
            { word: "database", meaning: "ë°ì´í„°ë² ì´ìŠ¤", type: "ëª…ì‚¬" },
            { word: "electron", meaning: "ì „ì", type: "ëª…ì‚¬" },
            { word: "fossil", meaning: "í™”ì„", type: "ëª…ì‚¬" },
            { word: "genome", meaning: "ê²Œë†ˆ", type: "ëª…ì‚¬" },
            { word: "hydrogen", meaning: "ìˆ˜ì†Œ", type: "ëª…ì‚¬" },
            { word: "innovation", meaning: "í˜ì‹ ", type: "ëª…ì‚¬" },
            { word: "junction", meaning: "ì ‘í•©ë¶€", type: "ëª…ì‚¬" },
            { word: "kinetic", meaning: "ìš´ë™ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "laser", meaning: "ë ˆì´ì €", type: "ëª…ì‚¬" },
            { word: "membrane", meaning: "ë§‰", type: "ëª…ì‚¬" },
            { word: "neutron", meaning: "ì¤‘ì„±ì", type: "ëª…ì‚¬" },
            { word: "organic", meaning: "ìœ ê¸°ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "protein", meaning: "ë‹¨ë°±ì§ˆ", type: "ëª…ì‚¬" },
            { word: "quantum", meaning: "ì–‘ì", type: "ëª…ì‚¬" },
            { word: "radiation", meaning: "ë°©ì‚¬ì„ ", type: "ëª…ì‚¬" },
            { word: "synthesis", meaning: "í•©ì„±", type: "ëª…ì‚¬" },
            { word: "velocity", meaning: "ì†ë„", type: "ëª…ì‚¬" }
        ]
    },
    travel: {
        name: "ì—¬í–‰ & êµí†µ",
        icon: "âœˆï¸",
        words: [
            { word: "accommodation", meaning: "ìˆ™ë°•ì‹œì„¤", type: "ëª…ì‚¬" },
            { word: "adventure", meaning: "ëª¨í—˜", type: "ëª…ì‚¬" },
            { word: "airport", meaning: "ê³µí•­", type: "ëª…ì‚¬" },
            { word: "booking", meaning: "ì˜ˆì•½", type: "ëª…ì‚¬" },
            { word: "culture", meaning: "ë¬¸í™”", type: "ëª…ì‚¬" },
            { word: "destination", meaning: "ëª©ì ì§€", type: "ëª…ì‚¬" },
            { word: "explore", meaning: "íƒí—˜í•˜ë‹¤", type: "ë™ì‚¬" },
            { word: "flight", meaning: "ë¹„í–‰í¸", type: "ëª…ì‚¬" },
            { word: "guide", meaning: "ê°€ì´ë“œ", type: "ëª…ì‚¬" },
            { word: "hotel", meaning: "í˜¸í…”", type: "ëª…ì‚¬" },
            { word: "itinerary", meaning: "ì¼ì •í‘œ", type: "ëª…ì‚¬" },
            { word: "journey", meaning: "ì—¬í–‰", type: "ëª…ì‚¬" },
            { word: "luggage", meaning: "ì§", type: "ëª…ì‚¬" },
            { word: "passport", meaning: "ì—¬ê¶Œ", type: "ëª…ì‚¬" },
            { word: "reservation", meaning: "ì˜ˆì•½", type: "ëª…ì‚¬" },
            { word: "sightseeing", meaning: "ê´€ê´‘", type: "ëª…ì‚¬" },
            { word: "ticket", meaning: "í‹°ì¼“", type: "ëª…ì‚¬" },
            { word: "tourist", meaning: "ê´€ê´‘ê°", type: "ëª…ì‚¬" },
            { word: "transportation", meaning: "êµí†µ", type: "ëª…ì‚¬" },
            { word: "vacation", meaning: "íœ´ê°€", type: "ëª…ì‚¬" },
            { word: "backpack", meaning: "ë°°ë‚­", type: "ëª…ì‚¬" },
            { word: "border", meaning: "êµ­ê²½", type: "ëª…ì‚¬" },
            { word: "currency", meaning: "í™”í", type: "ëª…ì‚¬" },
            { word: "departure", meaning: "ì¶œë°œ", type: "ëª…ì‚¬" },
            { word: "embassy", meaning: "ëŒ€ì‚¬ê´€", type: "ëª…ì‚¬" },
            { word: "festival", meaning: "ì¶•ì œ", type: "ëª…ì‚¬" },
            { word: "geography", meaning: "ì§€ë¦¬", type: "ëª…ì‚¬" },
            { word: "highway", meaning: "ê³ ì†ë„ë¡œ", type: "ëª…ì‚¬" },
            { word: "immigration", meaning: "ì¶œì…êµ­", type: "ëª…ì‚¬" },
            { word: "jet lag", meaning: "ì‹œì°¨ë³‘", type: "ëª…ì‚¬" },
            { word: "landmark", meaning: "ëœë“œë§ˆí¬", type: "ëª…ì‚¬" },
            { word: "metro", meaning: "ì§€í•˜ì² ", type: "ëª…ì‚¬" },
            { word: "navigation", meaning: "ë‚´ë¹„ê²Œì´ì…˜", type: "ëª…ì‚¬" },
            { word: "overseas", meaning: "í•´ì™¸ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "pilgrimage", meaning: "ìˆœë¡€", type: "ëª…ì‚¬" },
            { word: "railway", meaning: "ì² ë„", type: "ëª…ì‚¬" },
            { word: "souvenir", meaning: "ê¸°ë…í’ˆ", type: "ëª…ì‚¬" },
            { word: "terminal", meaning: "í„°ë¯¸ë„", type: "ëª…ì‚¬" },
            { word: "visa", meaning: "ë¹„ì", type: "ëª…ì‚¬" },
            { word: "voyage", meaning: "í•­í•´", type: "ëª…ì‚¬" }
        ]
    },
    daily: {
        name: "ì¼ìƒ ìƒí™œ",
        icon: "ğŸ ",
        words: [
            { word: "breakfast", meaning: "ì•„ì¹¨ì‹ì‚¬", type: "ëª…ì‚¬" },
            { word: "celebrate", meaning: "ì¶•í•˜í•˜ë‹¤", type: "ë™ì‚¬" },
            { word: "comfortable", meaning: "í¸ì•ˆí•œ", type: "í˜•ìš©ì‚¬" },
            { word: "dinner", meaning: "ì €ë…ì‹ì‚¬", type: "ëª…ì‚¬" },
            { word: "exercise", meaning: "ìš´ë™", type: "ëª…ì‚¬" },
            { word: "family", meaning: "ê°€ì¡±", type: "ëª…ì‚¬" },
            { word: "grocery", meaning: "ì‹ë£Œí’ˆ", type: "ëª…ì‚¬" },
            { word: "healthy", meaning: "ê±´ê°•í•œ", type: "í˜•ìš©ì‚¬" },
            { word: "kitchen", meaning: "ì£¼ë°©", type: "ëª…ì‚¬" },
            { word: "laundry", meaning: "ì„¸íƒ", type: "ëª…ì‚¬" },
            { word: "medicine", meaning: "ì•½", type: "ëª…ì‚¬" },
            { word: "neighbor", meaning: "ì´ì›ƒ", type: "ëª…ì‚¬" },
            { word: "outdoors", meaning: "ì•¼ì™¸", type: "ë¶€ì‚¬" },
            { word: "pet", meaning: "ì• ì™„ë™ë¬¼", type: "ëª…ì‚¬" },
            { word: "recipe", meaning: "ìš”ë¦¬ë²•", type: "ëª…ì‚¬" },
            { word: "shopping", meaning: "ì‡¼í•‘", type: "ëª…ì‚¬" },
            { word: "television", meaning: "í…”ë ˆë¹„ì „", type: "ëª…ì‚¬" },
            { word: "umbrella", meaning: "ìš°ì‚°", type: "ëª…ì‚¬" },
            { word: "vegetable", meaning: "ì•¼ì±„", type: "ëª…ì‚¬" },
            { word: "weekend", meaning: "ì£¼ë§", type: "ëª…ì‚¬" },
            { word: "appointment", meaning: "ì•½ì†", type: "ëª…ì‚¬" },
            { word: "budget", meaning: "ì˜ˆì‚°", type: "ëª…ì‚¬" },
            { word: "commute", meaning: "í†µê·¼í•˜ë‹¤", type: "ë™ì‚¬" },
            { word: "dentist", meaning: "ì¹˜ê³¼ì˜ì‚¬", type: "ëª…ì‚¬" },
            { word: "emergency", meaning: "ì‘ê¸‰ìƒí™©", type: "ëª…ì‚¬" },
            { word: "furniture", meaning: "ê°€êµ¬", type: "ëª…ì‚¬" },
            { word: "garbage", meaning: "ì“°ë ˆê¸°", type: "ëª…ì‚¬" },
            { word: "hobby", meaning: "ì·¨ë¯¸", type: "ëª…ì‚¬" },
            { word: "insurance", meaning: "ë³´í—˜", type: "ëª…ì‚¬" },
            { word: "journal", meaning: "ì¼ê¸°", type: "ëª…ì‚¬" },
            { word: "kindergarten", meaning: "ìœ ì¹˜ì›", type: "ëª…ì‚¬" },
            { word: "lifestyle", meaning: "ìƒí™œë°©ì‹", type: "ëª…ì‚¬" },
            { word: "maintenance", meaning: "ìœ ì§€ë³´ìˆ˜", type: "ëª…ì‚¬" },
            { word: "nutrition", meaning: "ì˜ì–‘", type: "ëª…ì‚¬" },
            { word: "organization", meaning: "ì •ë¦¬", type: "ëª…ì‚¬" },
            { word: "pharmacy", meaning: "ì•½êµ­", type: "ëª…ì‚¬" },
            { word: "routine", meaning: "ì¼ìƒ", type: "ëª…ì‚¬" },
            { word: "schedule", meaning: "ì¼ì •", type: "ëª…ì‚¬" },
            { word: "tradition", meaning: "ì „í†µ", type: "ëª…ì‚¬" },
            { word: "utility", meaning: "ê³µê³µìš”ê¸ˆ", type: "ëª…ì‚¬" }
        ]
    },
    academic: {
        name: "í•™ë¬¸ & êµìœ¡",
        icon: "ğŸ“š",
        words: [
            { word: "academic", meaning: "í•™ë¬¸ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "analysis", meaning: "ë¶„ì„", type: "ëª…ì‚¬" },
            { word: "assignment", meaning: "ê³¼ì œ", type: "ëª…ì‚¬" },
            { word: "calculate", meaning: "ê³„ì‚°í•˜ë‹¤", type: "ë™ì‚¬" },
            { word: "curriculum", meaning: "êµìœ¡ê³¼ì •", type: "ëª…ì‚¬" },
            { word: "debate", meaning: "í† ë¡ ", type: "ëª…ì‚¬" },
            { word: "education", meaning: "êµìœ¡", type: "ëª…ì‚¬" },
            { word: "examination", meaning: "ì‹œí—˜", type: "ëª…ì‚¬" },
            { word: "graduate", meaning: "ì¡¸ì—…ìƒ", type: "ëª…ì‚¬" },
            { word: "knowledge", meaning: "ì§€ì‹", type: "ëª…ì‚¬" },
            { word: "lecture", meaning: "ê°•ì˜", type: "ëª…ì‚¬" },
            { word: "library", meaning: "ë„ì„œê´€", type: "ëª…ì‚¬" },
            { word: "mathematics", meaning: "ìˆ˜í•™", type: "ëª…ì‚¬" },
            { word: "professor", meaning: "êµìˆ˜", type: "ëª…ì‚¬" },
            { word: "scholarship", meaning: "ì¥í•™ê¸ˆ", type: "ëª…ì‚¬" },
            { word: "semester", meaning: "í•™ê¸°", type: "ëª…ì‚¬" },
            { word: "student", meaning: "í•™ìƒ", type: "ëª…ì‚¬" },
            { word: "textbook", meaning: "êµê³¼ì„œ", type: "ëª…ì‚¬" },
            { word: "university", meaning: "ëŒ€í•™êµ", type: "ëª…ì‚¬" },
            { word: "vocabulary", meaning: "ì–´íœ˜", type: "ëª…ì‚¬" },
            { word: "bibliography", meaning: "ì°¸ê³ ë¬¸í—Œ", type: "ëª…ì‚¬" },
            { word: "certificate", meaning: "ì¦ëª…ì„œ", type: "ëª…ì‚¬" },
            { word: "discipline", meaning: "í•™ë¬¸ë¶„ì•¼", type: "ëª…ì‚¬" },
            { word: "essay", meaning: "ì—ì„¸ì´", type: "ëª…ì‚¬" },
            { word: "faculty", meaning: "êµìˆ˜ì§„", type: "ëª…ì‚¬" },
            { word: "grammar", meaning: "ë¬¸ë²•", type: "ëª…ì‚¬" },
            { word: "hypothesis", meaning: "ê°€ì„¤", type: "ëª…ì‚¬" },
            { word: "internship", meaning: "ì¸í„´ì‹­", type: "ëª…ì‚¬" },
            { word: "journal", meaning: "í•™ìˆ ì§€", type: "ëª…ì‚¬" },
            { word: "kindergarten", meaning: "ìœ ì¹˜ì›", type: "ëª…ì‚¬" },
            { word: "laboratory", meaning: "ì‹¤í—˜ì‹¤", type: "ëª…ì‚¬" },
            { word: "methodology", meaning: "ë°©ë²•ë¡ ", type: "ëª…ì‚¬" },
            { word: "notation", meaning: "í‘œê¸°ë²•", type: "ëª…ì‚¬" },
            { word: "outline", meaning: "ê°œìš”", type: "ëª…ì‚¬" },
            { word: "plagiarism", meaning: "í‘œì ˆ", type: "ëª…ì‚¬" },
            { word: "qualification", meaning: "ìê²©", type: "ëª…ì‚¬" },
            { word: "research", meaning: "ì—°êµ¬", type: "ëª…ì‚¬" },
            { word: "statistics", meaning: "í†µê³„í•™", type: "ëª…ì‚¬" },
            { word: "thesis", meaning: "ë…¼ë¬¸", type: "ëª…ì‚¬" },
            { word: "undergraduate", meaning: "í•™ë¶€ìƒ", type: "ëª…ì‚¬" }
        ]
    },
    technology: {
        name: "IT & ì»´í“¨í„°",
        icon: "ğŸ’»",
        words: [
            { word: "algorithm", meaning: "ì•Œê³ ë¦¬ì¦˜", type: "ëª…ì‚¬" },
            { word: "application", meaning: "ì• í”Œë¦¬ì¼€ì´ì…˜", type: "ëª…ì‚¬" },
            { word: "backup", meaning: "ë°±ì—…", type: "ëª…ì‚¬" },
            { word: "browser", meaning: "ë¸Œë¼ìš°ì €", type: "ëª…ì‚¬" },
            { word: "cloud", meaning: "í´ë¼ìš°ë“œ", type: "ëª…ì‚¬" },
            { word: "database", meaning: "ë°ì´í„°ë² ì´ìŠ¤", type: "ëª…ì‚¬" },
            { word: "download", meaning: "ë‹¤ìš´ë¡œë“œ", type: "ë™ì‚¬" },
            { word: "encryption", meaning: "ì•”í˜¸í™”", type: "ëª…ì‚¬" },
            { word: "firewall", meaning: "ë°©í™”ë²½", type: "ëª…ì‚¬" },
            { word: "graphics", meaning: "ê·¸ë˜í”½", type: "ëª…ì‚¬" },
            { word: "hardware", meaning: "í•˜ë“œì›¨ì–´", type: "ëª…ì‚¬" },
            { word: "interface", meaning: "ì¸í„°í˜ì´ìŠ¤", type: "ëª…ì‚¬" },
            { word: "javascript", meaning: "ìë°”ìŠ¤í¬ë¦½íŠ¸", type: "ëª…ì‚¬" },
            { word: "keyboard", meaning: "í‚¤ë³´ë“œ", type: "ëª…ì‚¬" },
            { word: "laptop", meaning: "ë…¸íŠ¸ë¶", type: "ëª…ì‚¬" },
            { word: "monitor", meaning: "ëª¨ë‹ˆí„°", type: "ëª…ì‚¬" },
            { word: "network", meaning: "ë„¤íŠ¸ì›Œí¬", type: "ëª…ì‚¬" },
            { word: "operating", meaning: "ìš´ì˜í•˜ëŠ”", type: "í˜•ìš©ì‚¬" },
            { word: "password", meaning: "ë¹„ë°€ë²ˆí˜¸", type: "ëª…ì‚¬" },
            { word: "processor", meaning: "í”„ë¡œì„¸ì„œ", type: "ëª…ì‚¬" },
            { word: "programming", meaning: "í”„ë¡œê·¸ë˜ë°", type: "ëª…ì‚¬" },
            { word: "router", meaning: "ë¼ìš°í„°", type: "ëª…ì‚¬" },
            { word: "server", meaning: "ì„œë²„", type: "ëª…ì‚¬" },
            { word: "software", meaning: "ì†Œí”„íŠ¸ì›¨ì–´", type: "ëª…ì‚¬" },
            { word: "storage", meaning: "ì €ì¥ì†Œ", type: "ëª…ì‚¬" },
            { word: "update", meaning: "ì—…ë°ì´íŠ¸", type: "ë™ì‚¬" },
            { word: "virus", meaning: "ë°”ì´ëŸ¬ìŠ¤", type: "ëª…ì‚¬" },
            { word: "website", meaning: "ì›¹ì‚¬ì´íŠ¸", type: "ëª…ì‚¬" },
            { word: "wireless", meaning: "ë¬´ì„ ì˜", type: "í˜•ìš©ì‚¬" },
            { word: "smartphone", meaning: "ìŠ¤ë§ˆíŠ¸í°", type: "ëª…ì‚¬" },
            { word: "artificial", meaning: "ì¸ê³µì˜", type: "í˜•ìš©ì‚¬" },
            { word: "intelligence", meaning: "ì§€ëŠ¥", type: "ëª…ì‚¬" },
            { word: "machine", meaning: "ê¸°ê³„", type: "ëª…ì‚¬" },
            { word: "learning", meaning: "í•™ìŠµ", type: "ëª…ì‚¬" },
            { word: "virtual", meaning: "ê°€ìƒì˜", type: "í˜•ìš©ì‚¬" },
            { word: "reality", meaning: "í˜„ì‹¤", type: "ëª…ì‚¬" },
            { word: "blockchain", meaning: "ë¸”ë¡ì²´ì¸", type: "ëª…ì‚¬" },
            { word: "cryptocurrency", meaning: "ì•”í˜¸í™”í", type: "ëª…ì‚¬" },
            { word: "cybersecurity", meaning: "ì‚¬ì´ë²„ë³´ì•ˆ", type: "ëª…ì‚¬" },
            { word: "automation", meaning: "ìë™í™”", type: "ëª…ì‚¬" }
        ]
    }
};

class VocabularyQuiz {
    constructor() {
        this.currentTheme = null;
        this.currentWordIndex = 0;
        this.totalQuestions = 0;
        this.correctAnswers = 0;
        this.usedIndices = [];
        this.currentChoices = [];
        this.correctChoiceIndex = 0;
        this.selectedChoice = null;
        this.autoAdvanceEnabled = false;
        this.autoAdvanceTimeout = null;
        
        // Challenge mode properties
        this.challengeMode = false;
        this.currentChallenge = null;
        
        // Review mode properties
        this.reviewMode = false;
        this.reviewWords = [];
        
        // Progress tracking
        this.userProgress = this.loadUserProgress();
        this.sessionStats = {
            wordsLearned: 0,
            correctAnswers: 0,
            totalAnswers: 0,
            startTime: Date.now(),
            questionStartTime: null,
            actualStudyTime: 0
        };
        
        // Speech synthesis for pronunciation
        this.speechSynthesis = window.speechSynthesis;
        this.voice = null;
        this.initVoice();
        
        this.initElements();
        this.bindEvents();
        
        // Initialize leaderboard manager
        this.initializeLeaderboard();
        
        // ì±Œë¦°ì§€ ëª¨ë“œ í™•ì¸
        this.checkChallengeMode() || this.showThemeSelector();
    }
    
    // Progress Management Methods
    loadUserProgress() {
        try {
            const saved = localStorage.getItem('vocabularyQuizProgress');
            const progress = saved ? JSON.parse(saved) : {
                completedThemes: {},
                totalWordsLearned: 0,
                bestScores: {},
                learningStreak: 0,
                lastPlayDate: null,
                wrongAnswers: {},
                totalSessionTime: 0,
                learnedWords: [],
                actualStudyTime: 0
            };
            
            // Ensure new properties exist for backward compatibility
            if (!progress.learnedWords) progress.learnedWords = [];
            if (typeof progress.actualStudyTime === 'undefined') progress.actualStudyTime = 0;
            if (!progress.completedThemes) progress.completedThemes = {};
            if (!progress.bestScores) progress.bestScores = {};
            if (!progress.wrongAnswers) progress.wrongAnswers = {};
            
            return progress;
        } catch (error) {
            console.warn('Could not load user progress:', error);
            return {
                completedThemes: {},
                totalWordsLearned: 0,
                bestScores: {},
                learningStreak: 0,
                lastPlayDate: null,
                wrongAnswers: {},
                totalSessionTime: 0,
                learnedWords: [],
                actualStudyTime: 0
            };
        }
    }
    
    saveUserProgress() {
        try {
            localStorage.setItem('vocabularyQuizProgress', JSON.stringify(this.userProgress));
        } catch (error) {
            console.warn('Could not save user progress:', error);
        }
    }
    
    updateProgress(themeKey, score, accuracy) {
        const today = new Date().toDateString();
        
        // Update theme completion
        if (!this.userProgress.completedThemes[themeKey]) {
            this.userProgress.completedThemes[themeKey] = {
                timesCompleted: 0,
                bestScore: 0,
                lastCompleted: null,
                totalAttempts: 0
            };
        }
        
        const themeProgress = this.userProgress.completedThemes[themeKey];
        themeProgress.timesCompleted++;
        themeProgress.totalAttempts++;
        themeProgress.lastCompleted = today;
        themeProgress.bestScore = Math.max(themeProgress.bestScore, score);
        
        // Update best scores
        this.userProgress.bestScores[themeKey] = Math.max(
            this.userProgress.bestScores[themeKey] || 0,
            score
        );
        
        // Update learning streak
        if (this.userProgress.lastPlayDate !== today) {
            if (this.userProgress.lastPlayDate === new Date(Date.now() - 86400000).toDateString()) {
                this.userProgress.learningStreak++;
            } else {
                this.userProgress.learningStreak = 1;
            }
            this.userProgress.lastPlayDate = today;
        }
        
        // Update session stats with accurate study time
        this.userProgress.actualStudyTime += this.sessionStats.actualStudyTime;
        
        // Track unique words learned in this theme
        const themeWords = vocabularyThemes[themeKey].words;
        for (const word of themeWords) {
            const wordKey = `${themeKey}_${word.word}`;
            if (!this.userProgress.learnedWords.includes(wordKey)) {
                this.userProgress.learnedWords.push(wordKey);
            }
        }
        
        // Update total words learned (accurate count)
        this.userProgress.totalWordsLearned = this.userProgress.learnedWords.length;
        
        this.saveUserProgress();
    }
    
    trackWrongAnswer() {
        const currentWord = vocabularyThemes[this.currentTheme].words[this.currentWordIndex];
        const wrongAnswerKey = `${this.currentTheme}_${this.currentWordIndex}`;
        
        if (!this.userProgress.wrongAnswers[this.currentTheme]) {
            this.userProgress.wrongAnswers[this.currentTheme] = {};
        }
        
        if (!this.userProgress.wrongAnswers[this.currentTheme][wrongAnswerKey]) {
            this.userProgress.wrongAnswers[this.currentTheme][wrongAnswerKey] = {
                word: currentWord.word,
                meaning: currentWord.meaning,
                type: currentWord.type,
                wrongCount: 0,
                lastWrong: null
            };
        }
        
        this.userProgress.wrongAnswers[this.currentTheme][wrongAnswerKey].wrongCount++;
        this.userProgress.wrongAnswers[this.currentTheme][wrongAnswerKey].lastWrong = new Date().toISOString();
        
        this.saveUserProgress();
    }
    
    getWrongAnswersForReview(themeKey = null) {
        const wrongAnswers = [];
        
        if (themeKey) {
            // Get wrong answers for specific theme
            const themeWrong = this.userProgress.wrongAnswers[themeKey] || {};
            Object.values(themeWrong).forEach(item => {
                wrongAnswers.push({
                    ...item,
                    theme: themeKey
                });
            });
        } else {
            // Get all wrong answers
            Object.keys(this.userProgress.wrongAnswers).forEach(theme => {
                const themeWrong = this.userProgress.wrongAnswers[theme] || {};
                Object.values(themeWrong).forEach(item => {
                    wrongAnswers.push({
                        ...item,
                        theme: theme
                    });
                });
            });
        }
        
        // Sort by most recent first
        return wrongAnswers.sort((a, b) => new Date(b.lastWrong) - new Date(a.lastWrong));
    }
    
    startReview(themeKey) {
        const wrongAnswers = this.getWrongAnswersForReview(themeKey);
        
        if (wrongAnswers.length === 0) {
            alert('ë³µìŠµí•  í‹€ë¦° ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤!');
            return;
        }
        
        // Create custom word list for review
        this.reviewMode = true;
        this.reviewWords = wrongAnswers;
        this.currentTheme = themeKey;
        this.usedIndices = [];
        this.totalQuestions = 0;
        this.correctAnswers = 0;
        
        this.currentThemeLabel.textContent = `${vocabularyThemes[themeKey].name} (ë³µìŠµ ëª¨ë“œ)`;
        this.updateScore();
        
        this.themeSelector.style.display = 'none';
        this.mainContent.style.display = 'block';
        
        this.loadReviewWord();
    }
    
    loadReviewWord() {
        if (this.usedIndices.length >= this.reviewWords.length) {
            // Review completed
            this.reviewMode = false;
            this.showCompletionModal();
            return;
        }
        
        let randomIndex;
        do {
            randomIndex = Math.floor(Math.random() * this.reviewWords.length);
        } while (this.usedIndices.includes(randomIndex));
        
        this.usedIndices.push(randomIndex);
        this.currentWordIndex = randomIndex;
        
        const reviewWord = this.reviewWords[randomIndex];
        
        this.wordElement.textContent = reviewWord.word;
        this.wordTypeElement.textContent = reviewWord.type;
        
        // Generate choices for review word
        const choiceData = this.generateChoicesForReview(reviewWord);
        this.currentChoices = choiceData.choices;
        this.correctChoiceIndex = choiceData.correctIndex;
        this.selectedChoice = null;
        
        // Update choice elements
        for (let i = 0; i < 4; i++) {
            const choiceElement = document.getElementById(`choice${i}`);
            const choiceItem = choiceElement.parentElement;
            
            choiceElement.textContent = this.currentChoices[i] || '';
            choiceItem.className = 'choice-item';
            // Remove all selection/result classes
            choiceItem.classList.remove('correct', 'incorrect', 'selected');
        }
        
        this.feedbackElement.textContent = '';
        this.feedbackElement.className = 'feedback';
        this.nextBtn.style.display = 'none';
        
        // Update question progress counter
        this.updateQuestionProgress();
        this.updateProgress();
        
        // Record question start time for accurate study time tracking
        this.sessionStats.questionStartTime = Date.now();
    }
    
    generateChoicesForReview(reviewWord) {
        const choices = [reviewWord.meaning];
        
        // Get all possible meanings from all themes except the correct one
        const allMeanings = [];
        Object.keys(vocabularyThemes).forEach(themeKey => {
            vocabularyThemes[themeKey].words.forEach(word => {
                if (word.meaning !== reviewWord.meaning) {
                    allMeanings.push(word.meaning);
                }
            });
        });
        
        // Add random wrong choices
        while (choices.length < 4 && allMeanings.length > 0) {
            const randomIndex = Math.floor(Math.random() * allMeanings.length);
            const randomMeaning = allMeanings[randomIndex];
            
            if (!choices.includes(randomMeaning)) {
                choices.push(randomMeaning);
            }
            allMeanings.splice(randomIndex, 1);
        }
        
        // Shuffle choices
        const shuffledChoices = [...choices];
        for (let i = shuffledChoices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffledChoices[i], shuffledChoices[j]] = [shuffledChoices[j], shuffledChoices[i]];
        }
        
        return {
            choices: shuffledChoices,
            correctIndex: shuffledChoices.indexOf(reviewWord.meaning)
        };
    }
    
    // Statistics Dashboard Methods
    showStatsDashboard() {
        this.themeSelector.style.display = 'none';
        this.statsDashboard.style.display = 'block';
        this.populateStatsDashboard();
    }
    
    hideStatsDashboard() {
        this.statsDashboard.style.display = 'none';
        this.themeSelector.style.display = 'block';
    }
    
    populateStatsDashboard() {
        this.updateOverviewStats();
        this.updateThemeStats();
        this.updateReviewStats();
    }
    
    updateOverviewStats() {
        // Learning streak
        document.getElementById('learningStreak').textContent = this.userProgress.learningStreak;
        
        // Total words learned (accurate count)
        const totalWords = this.userProgress.totalWordsLearned || this.userProgress.learnedWords.length || 0;
        document.getElementById('totalWordsLearned').textContent = totalWords;
        
        // Total study time (convert milliseconds to minutes)
        const totalMinutes = Math.round((this.userProgress.actualStudyTime || this.userProgress.totalSessionTime || 0) / (1000 * 60));
        document.getElementById('totalStudyTime').textContent = `${totalMinutes}ë¶„`;
        
        // Average score
        const scores = Object.values(this.userProgress.bestScores);
        const averageScore = scores.length > 0 ? Math.round(scores.reduce((a, b) => a + b, 0) / scores.length) : 0;
        document.getElementById('averageScore').textContent = `${averageScore}ì `;
    }
    
    updateThemeStats() {
        const themeStatsGrid = document.getElementById('themeStatsGrid');
        themeStatsGrid.innerHTML = '';
        
        Object.keys(vocabularyThemes).forEach(themeKey => {
            const theme = vocabularyThemes[themeKey];
            const themeProgress = this.userProgress.completedThemes[themeKey];
            const bestScore = this.userProgress.bestScores[themeKey] || 0;
            const wrongAnswersCount = Object.keys(this.userProgress.wrongAnswers[themeKey] || {}).length;
            
            const themeStatItem = document.createElement('div');
            themeStatItem.className = 'theme-stat-item';
            
            const completionCount = themeProgress ? themeProgress.timesCompleted : 0;
            const lastCompleted = themeProgress ? themeProgress.lastCompleted : 'ì—†ìŒ';
            
            themeStatItem.innerHTML = `
                <div class="theme-stat-header">
                    <span class="theme-stat-icon">${theme.icon}</span>
                    <span class="theme-stat-name">${theme.name}</span>
                </div>
                <div class="theme-stat-details">
                    <div class="theme-stat-detail">
                        <span class="theme-stat-label">ìµœê³  ì ìˆ˜</span>
                        <span class="theme-stat-value">${bestScore}ì </span>
                    </div>
                    <div class="theme-stat-detail">
                        <span class="theme-stat-label">ì™„ì£¼ íšŸìˆ˜</span>
                        <span class="theme-stat-value">${completionCount}íšŒ</span>
                    </div>
                    <div class="theme-stat-detail">
                        <span class="theme-stat-label">í‹€ë¦° ë¬¸ì œ</span>
                        <span class="theme-stat-value">${wrongAnswersCount}ê°œ</span>
                    </div>
                    <div class="theme-stat-detail">
                        <span class="theme-stat-label">ë§ˆì§€ë§‰ í•™ìŠµ</span>
                        <span class="theme-stat-value">${lastCompleted}</span>
                    </div>
                </div>
            `;
            
            themeStatsGrid.appendChild(themeStatItem);
        });
    }
    
    updateReviewStats() {
        const reviewSummary = document.getElementById('reviewSummary');
        
        let totalWrongAnswers = 0;
        let themesWithWrongAnswers = 0;
        
        Object.keys(this.userProgress.wrongAnswers).forEach(themeKey => {
            const wrongCount = Object.keys(this.userProgress.wrongAnswers[themeKey] || {}).length;
            if (wrongCount > 0) {
                totalWrongAnswers += wrongCount;
                themesWithWrongAnswers++;
            }
        });
        
        let reviewMessage = '';
        if (totalWrongAnswers === 0) {
            reviewMessage = 'ì¶•í•˜í•©ë‹ˆë‹¤! ë³µìŠµí•  í‹€ë¦° ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤! ğŸ‰';
        } else {
            reviewMessage = `ë³µìŠµì´ í•„ìš”í•œ ë¬¸ì œë“¤ì´ ìˆìŠµë‹ˆë‹¤. ì§€ì†ì ì¸ ë³µìŠµìœ¼ë¡œ ì™„ë²½í•˜ê²Œ ë§ˆìŠ¤í„°í•´ë³´ì„¸ìš”! ğŸ’ª`;
        }
        
        reviewSummary.innerHTML = `
            <div class="review-summary-title">${reviewMessage}</div>
            <div class="review-summary-stats">
                <div class="review-summary-stat">
                    <div class="review-summary-number">${totalWrongAnswers}</div>
                    <div class="review-summary-label">ì´ í‹€ë¦° ë¬¸ì œ</div>
                </div>
                <div class="review-summary-stat">
                    <div class="review-summary-number">${themesWithWrongAnswers}</div>
                    <div class="review-summary-label">ë³µìŠµ í•„ìš” í…Œë§ˆ</div>
                </div>
                <div class="review-summary-stat">
                    <div class="review-summary-number">${6 - themesWithWrongAnswers}</div>
                    <div class="review-summary-label">ì™„ë²½ ë§ˆìŠ¤í„° í…Œë§ˆ</div>
                </div>
            </div>
        `;
    }
    
    // Social Features Methods
    async shareScore(score, accuracy, themeName) {
        try {
            // Generate score card image
            const imageBlob = await this.generateScoreCard(score, accuracy, themeName);
            
            if (navigator.share && navigator.canShare) {
                const testFile = new File([imageBlob], 'score.png', { type: 'image/png' });
                const canShareFiles = navigator.canShare({ files: [testFile] });
                
                if (canShareFiles) {
                    // Share with image (supported on mobile)
                    const file = new File([imageBlob], 'english-master-score.png', { type: 'image/png' });
                    await navigator.share({
                        title: 'ğŸ¯ ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„° - ì ìˆ˜ ê³µìœ ',
                        text: `${themeName} í…Œë§ˆì—ì„œ ${score}ì ì„ ë‹¬ì„±í–ˆì–´ìš”! ğŸ‰`,
                        files: [file]
                    });
                } else {
                    // Fallback: download image and show share text
                    this.downloadScoreCard(imageBlob, `ì˜ì–´ë‹¨ì–´ë§ˆìŠ¤í„°_${themeName}_${score}ì .png`);
                    this.showToast('ğŸ“¸ ì ìˆ˜ ì¹´ë“œê°€ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!\nì´ë¯¸ì§€ë¥¼ SNSì— ì˜¬ë ¤ë³´ì„¸ìš”!');
                }
            } else {
                // Fallback: download image and show share text
                this.downloadScoreCard(imageBlob, `ì˜ì–´ë‹¨ì–´ë§ˆìŠ¤í„°_${themeName}_${score}ì .png`);
                this.showToast('ğŸ“¸ ì ìˆ˜ ì¹´ë“œê°€ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!\nì´ë¯¸ì§€ë¥¼ SNSì— ì˜¬ë ¤ë³´ì„¸ìš”!');
            }
        } catch (error) {
            console.error('Error sharing score:', error);
            // Fallback to text sharing
            const shareText = `ğŸ¯ ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„°ì—ì„œ ${themeName} í…Œë§ˆë¥¼ ì™„ì£¼í–ˆì–´ìš”!\nğŸ“Š ì ìˆ˜: ${score}ì  | ì •ë‹µë¥ : ${accuracy}%\n\ní•¨ê»˜ ì˜ì–´ ë‹¨ì–´ë¥¼ ë§ˆìŠ¤í„°í•´ë³´ì„¸ìš”! ğŸš€`;
            const appUrl = 'https://prepaid114.github.io/prepaid114/';
            this.fallbackShare(shareText, appUrl);
        }
    }
    
    shareStats() {
        const streak = this.userProgress.learningStreak;
        const totalWords = this.userProgress.totalWordsLearned || this.userProgress.learnedWords.length;
        const totalMinutes = Math.round((this.userProgress.actualStudyTime || this.userProgress.totalSessionTime) / (1000 * 60));
        const completedThemes = Object.keys(this.userProgress.completedThemes).length;
        
        const shareText = `ğŸ“š ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„° í•™ìŠµ í˜„í™© ğŸ“š\n\nğŸ”¥ ì—°ì† í•™ìŠµ: ${streak}ì¼\nğŸ“– í•™ìŠµí•œ ë‹¨ì–´: ${totalWords}ê°œ\nâ±ï¸ ì´ í•™ìŠµì‹œê°„: ${totalMinutes}ë¶„\nğŸ¯ ì™„ë£Œí•œ í…Œë§ˆ: ${completedThemes}ê°œ\n\nê¾¸ì¤€í•œ í•™ìŠµìœ¼ë¡œ ì˜ì–´ ì‹¤ë ¥ì„ í‚¤ì›Œê°€ê³  ìˆì–´ìš”! ğŸ’ª`;
        const appUrl = 'https://prepaid114.github.io/prepaid114/';
        
        if (navigator.share) {
            navigator.share({
                title: 'ğŸ“š ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„° - í•™ìŠµ í†µê³„',
                text: shareText,
                url: appUrl
            }).catch(err => {
                console.log('Error sharing:', err);
                this.fallbackShare(shareText, appUrl);
            });
        } else {
            this.fallbackShare(shareText, appUrl);
        }
    }
    
    async challengeFriends() {
        // í˜„ì¬ ì‚¬ìš©ìì˜ ìµœê³  ê¸°ë¡ ê°€ì ¸ì˜¤ê¸°
        const bestScores = this.userProgress.bestScores;
        const availableThemes = Object.keys(bestScores).filter(theme => bestScores[theme] > 0);
        
        if (availableThemes.length === 0) {
            this.showToast('ë¨¼ì € í…Œë§ˆë¥¼ ì™„ì£¼í•œ í›„ ì¹œêµ¬ì—ê²Œ ë„ì „ì¥ì„ ë³´ë‚¼ ìˆ˜ ìˆì–´ìš”!');
            return;
        }
        
        // ë„ì „í•  í…Œë§ˆ ì„ íƒ (ê°€ì¥ ë†’ì€ ì ìˆ˜ì˜ í…Œë§ˆ)
        const bestTheme = Object.keys(bestScores).reduce((a, b) => 
            bestScores[a] > bestScores[b] ? a : b
        );
        const bestScore = bestScores[bestTheme];
        const themeName = vocabularyThemes[bestTheme].name;
        
        // ì±Œë¦°ì§€ ìƒì„±
        const challenge = this.createChallenge(bestTheme, bestScore, themeName);
        
        try {
            // ì±Œë¦°ì§€ ì¹´ë“œ ì´ë¯¸ì§€ ìƒì„±
            const imageBlob = await this.generateChallengeCard(challenge);
            
            if (navigator.share && navigator.canShare && navigator.canShare({ files: [new File([imageBlob], 'challenge.png', { type: 'image/png' })] })) {
                // Share with image
                const file = new File([imageBlob], 'english-master-challenge.png', { type: 'image/png' });
                await navigator.share({
                    title: 'ğŸ¯ ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„° - ë„ì „ì¥',
                    text: `${themeName} í…Œë§ˆì—ì„œ ${bestScore}ì ì— ë„ì „í•´ë³´ì„¸ìš”! ğŸ†`,
                    files: [file]
                });
            } else {
                // Fallback: download image and show challenge URL
                this.downloadScoreCard(imageBlob, `ì˜ì–´ë‹¨ì–´ë§ˆìŠ¤í„°_ë„ì „ì¥_${themeName}.png`);
                const challengeUrl = `${window.location.origin}${window.location.pathname}?challenge=${challenge.id}`;
                
                await navigator.clipboard.writeText(challengeUrl);
                this.showToast('ğŸ¯ ë„ì „ì¥ ì´ë¯¸ì§€ê°€ ë‹¤ìš´ë¡œë“œë˜ê³  ë§í¬ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!\nì¹œêµ¬ì—ê²Œ ì´ë¯¸ì§€ì™€ ë§í¬ë¥¼ í•¨ê»˜ ë³´ë‚´ë³´ì„¸ìš”!');
            }
        } catch (error) {
            console.error('Error creating challenge:', error);
            // Text fallback
            const challengeUrl = `${window.location.origin}${window.location.pathname}?challenge=${challenge.id}`;
            const challengeText = `ğŸ¯ ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„° ë„ì „ì¥! ğŸ¯\n\n${themeName} í…Œë§ˆì—ì„œ ë‚´ ê¸°ë¡ ${bestScore}ì ì„ ë„˜ì–´ë³´ì„¸ìš”!\n\n${challengeUrl}`;
            this.fallbackShare(challengeText, '');
        }
    }
    
    createChallenge(themeKey, targetScore, themeName) {
        const challengeId = this.generateChallengeId();
        const challenge = {
            id: challengeId,
            theme: themeKey,
            themeName: themeName,
            targetScore: targetScore,
            createdAt: Date.now(),
            creatorName: 'ë„ì „ì', // ì¶”í›„ ì‚¬ìš©ì ì´ë¦„ ê¸°ëŠ¥ ì¶”ê°€ ì‹œ ì‚¬ìš©
        };
        
        // LocalStorageì— ì±Œë¦°ì§€ ì €ì¥
        const challenges = JSON.parse(localStorage.getItem('englishMasterChallenges') || '{}');
        challenges[challengeId] = challenge;
        localStorage.setItem('englishMasterChallenges', JSON.stringify(challenges));
        
        return challenge;
    }
    
    generateChallengeId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }
    
    async generateChallengeCard(challenge) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = 800;
        canvas.height = 800;
        
        const themeColors = this.getThemeColors(challenge.theme);
        const themeIcon = vocabularyThemes[challenge.theme].icon;
        
        // ë°°ê²½ (ë„ì „ì¥ ëŠë‚Œì˜ ë‹¤ë¥¸ ìƒ‰ìƒ)
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, '#ff6b6b');
        gradient.addColorStop(0.5, '#ffd93d');
        gradient.addColorStop(1, '#6c5ce7');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // ì¹´ë“œ ë°°ê²½
        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.roundRect(50, 80, canvas.width - 100, canvas.height - 160, 30);
        ctx.fill();
        
        // ë„ì „ì¥ íƒ€ì´í‹€
        ctx.fillStyle = '#e74c3c';
        ctx.font = 'bold 52px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('ğŸ¯ ë„ì „ì¥! ğŸ¯', canvas.width / 2, 180);
        
        // í…Œë§ˆ ì •ë³´
        ctx.font = '60px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = '#2c3e50';
        ctx.fillText(themeIcon, canvas.width / 2, 280);
        
        ctx.font = 'bold 32px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillText(challenge.themeName, canvas.width / 2, 330);
        
        // ë„ì „ ë©”ì‹œì§€
        ctx.font = 'bold 28px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = '#666';
        ctx.fillText('ì´ ì ìˆ˜ë¥¼ ë„˜ì–´ë³´ì„¸ìš”!', canvas.width / 2, 400);
        
        // ëª©í‘œ ì ìˆ˜
        ctx.font = 'bold 100px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = themeColors.accent;
        ctx.fillText(`${challenge.targetScore}ì `, canvas.width / 2, 520);
        
        // ë„ì „ ë²„íŠ¼ íš¨ê³¼
        ctx.fillStyle = '#e74c3c';
        ctx.roundRect(250, 560, 300, 60, 30);
        ctx.fill();
        
        ctx.fillStyle = 'white';
        ctx.font = 'bold 28px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillText('ë„ì „í•˜ê¸°!', canvas.width / 2, 600);
        
        // ì•± ì •ë³´
        ctx.font = '24px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = '#999';
        ctx.fillText('ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„°', canvas.width / 2, 680);
        ctx.font = '20px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillText('prepaid114.github.io/prepaid114', canvas.width / 2, 720);
        
        return new Promise(resolve => {
            canvas.toBlob(resolve, 'image/png', 0.9);
        });
    }
    
    async copyAppLink() {
        const appUrl = 'https://prepaid114.github.io/prepaid114/';
        const linkText = `ğŸ¯ ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„°\n\ní…Œë§ˆë³„ ì˜ì–´ ë‹¨ì–´ í•™ìŠµ ì•±\nğŸ“š 240ê°œ ë‹¨ì–´ | ğŸ”Š ì›ì–´ë¯¼ ë°œìŒ | ğŸ“± ëª¨ë°”ì¼ ìµœì í™”\n\n${appUrl}`;
        
        try {
            if (navigator.clipboard) {
                await navigator.clipboard.writeText(linkText);
                this.showToast('âœ… ë§í¬ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
            } else {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = linkText;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                this.showToast('âœ… ë§í¬ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
            }
        } catch (err) {
            console.error('Failed to copy link:', err);
            this.showToast('âŒ ë§í¬ ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì§ì ‘ ë³µì‚¬í•´ì£¼ì„¸ìš”.');
            // Show the link in an alert as fallback
            alert(`ë§í¬ë¥¼ ì§ì ‘ ë³µì‚¬í•´ì£¼ì„¸ìš”:\n\n${linkText}`);
        }
    }
    
    fallbackShare(text, url) {
        const fullText = `${text}\n\n${url}`;
        
        // Try to copy to clipboard first
        if (navigator.clipboard) {
            navigator.clipboard.writeText(fullText).then(() => {
                this.showToast('ğŸ“‹ í…ìŠ¤íŠ¸ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!\nì¹´ì¹´ì˜¤í†¡, ë¬¸ì ë“±ì— ë¶™ì—¬ë„£ê¸° í•˜ì„¸ìš”.');
            }).catch(() => {
                this.showShareAlert(fullText);
            });
        } else {
            this.showShareAlert(fullText);
        }
    }
    
    showShareAlert(text) {
        alert(`ë‹¤ìŒ ë‚´ìš©ì„ ë³µì‚¬í•´ì„œ ê³µìœ í•´ì£¼ì„¸ìš”:\n\n${text}`);
    }
    
    showToast(message) {
        // Create toast notification
        const toast = document.createElement('div');
        toast.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            z-index: 10000;
            font-size: 0.9rem;
            text-align: center;
            max-width: 90%;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        `;
        toast.textContent = message;
        
        document.body.appendChild(toast);
        
        // Remove toast after 3 seconds
        setTimeout(() => {
            if (document.body.contains(toast)) {
                document.body.removeChild(toast);
            }
        }, 3000);
    }
    
    // Score Card Image Generation
    async generateScoreCard(score, accuracy, themeName) {
        // Ensure roundRect polyfill is available
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
                this.beginPath();
                this.moveTo(x + radius, y);
                this.lineTo(x + width - radius, y);
                this.quadraticCurveTo(x + width, y, x + width, y + radius);
                this.lineTo(x + width, y + height - radius);
                this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                this.lineTo(x + radius, y + height);
                this.quadraticCurveTo(x, y + height, x, y + height - radius);
                this.lineTo(x, y + radius);
                this.quadraticCurveTo(x, y, x + radius, y);
                this.closePath();
            };
        }
        
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        if (!ctx) {
            throw new Error('Canvas 2D context not supported');
        }
        
        // Canvas í¬ê¸° ì„¤ì • (Instagram Square format)
        canvas.width = 800;
        canvas.height = 800;
        
        // í…Œë§ˆë³„ ìƒ‰ìƒ ë° ì•„ì´ì½˜ ê°€ì ¸ì˜¤ê¸°
        const themeKey = Object.keys(vocabularyThemes).find(key => 
            vocabularyThemes[key].name === themeName
        );
        const themeIcon = themeKey ? vocabularyThemes[themeKey].icon : 'ğŸ“š';
        const themeColors = this.getThemeColors(themeKey);
        
        // ë°°ê²½ ê·¸ë¼ë°ì´ì…˜
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, themeColors.primary);
        gradient.addColorStop(1, themeColors.secondary);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // ë°˜íˆ¬ëª… ì˜¤ë²„ë ˆì´
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // ì¹´ë“œ ì»¨í…Œì´ë„ˆ
        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.roundRect(50, 100, canvas.width - 100, canvas.height - 200, 30);
        ctx.fill();
        
        // ì œëª©
        ctx.fillStyle = '#2c3e50';
        ctx.font = 'bold 48px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('ğŸ¯ ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„°', canvas.width / 2, 200);
        
        // í…Œë§ˆ ì•„ì´ì½˜ ë° ì´ë¦„
        ctx.font = '80px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillText(themeIcon, canvas.width / 2, 320);
        
        ctx.font = 'bold 36px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillText(themeName, canvas.width / 2, 380);
        
        // ì ìˆ˜ (ë©”ì¸)
        ctx.font = 'bold 120px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = themeColors.accent;
        ctx.fillText(`${score}ì `, canvas.width / 2, 520);
        
        // ì •ë‹µë¥ 
        ctx.font = 'bold 32px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = '#666';
        ctx.fillText(`ì •ë‹µë¥  ${accuracy}%`, canvas.width / 2, 580);
        
        // ì •ë‹µë¥  ë°” ì°¨íŠ¸
        const barWidth = 300;
        const barHeight = 20;
        const barX = (canvas.width - barWidth) / 2;
        const barY = 600;
        
        // ë°°ê²½ ë°”
        ctx.fillStyle = '#e0e0e0';
        ctx.roundRect(barX, barY, barWidth, barHeight, 10);
        ctx.fill();
        
        // ì§„í–‰ ë°”
        ctx.fillStyle = themeColors.accent;
        ctx.roundRect(barX, barY, (barWidth * accuracy) / 100, barHeight, 10);
        ctx.fill();
        
        // ì™„ë£Œ ì‹œê°„
        const now = new Date();
        const dateString = now.toLocaleDateString('ko-KR');
        ctx.font = '24px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = '#999';
        ctx.fillText(`${dateString} ì™„ë£Œ`, canvas.width / 2, 680);
        
        // URL
        ctx.font = '20px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillText('prepaid114.github.io/prepaid114', canvas.width / 2, 720);
        
        // Canvas to Blob
        return new Promise(resolve => {
            canvas.toBlob(resolve, 'image/png', 0.9);
        });
    }
    
    getThemeColors(themeKey) {
        const colorMap = {
            business: { primary: '#ff6b6b', secondary: '#ee5a24', accent: '#e74c3c' },
            science: { primary: '#4ecdc4', secondary: '#44a08d', accent: '#16a085' },
            travel: { primary: '#f093fb', secondary: '#f5576c', accent: '#e91e63' },
            daily: { primary: '#a8edea', secondary: '#fed6e3', accent: '#ff9a56' },
            academic: { primary: '#667eea', secondary: '#764ba2', accent: '#5a6fd8' },
            technology: { primary: '#ff9a56', secondary: '#ff6b6b', accent: '#ff5722' }
        };
        
        return colorMap[themeKey] || colorMap.academic;
    }
    
    downloadScoreCard(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
    
    // Challenge System
    checkChallengeMode() {
        const urlParams = new URLSearchParams(window.location.search);
        const challengeId = urlParams.get('challenge');
        
        if (challengeId) {
            const challenges = JSON.parse(localStorage.getItem('englishMasterChallenges') || '{}');
            const challenge = challenges[challengeId];
            
            if (challenge) {
                this.startChallengeMode(challenge);
                return true;
            } else {
                this.showToast('âŒ ìœ íš¨í•˜ì§€ ì•Šì€ ë„ì „ì¥ì…ë‹ˆë‹¤.');
                // URLì—ì„œ ì±Œë¦°ì§€ íŒŒë¼ë¯¸í„° ì œê±°
                window.history.replaceState({}, document.title, window.location.pathname);
            }
        }
        return false;
    }
    
    startChallengeMode(challenge) {
        this.challengeMode = true;
        this.currentChallenge = challenge;
        
        // ì±Œë¦°ì§€ ì •ë³´ í‘œì‹œ
        this.showChallengeInfo(challenge);
    }
    
    showChallengeInfo(challenge) {
        // ê¸°ì¡´ ìš”ì†Œë“¤ ìˆ¨ê¸°ê¸°
        this.themeSelector.style.display = 'none';
        this.mainContent.style.display = 'none';
        
        // ì±Œë¦°ì§€ ì •ë³´ ëª¨ë‹¬ ìƒì„±
        this.createChallengeModal(challenge);
    }
    
    createChallengeModal(challenge) {
        // ê¸°ì¡´ ì±Œë¦°ì§€ ëª¨ë‹¬ì´ ìˆìœ¼ë©´ ì œê±°
        const existingModal = document.getElementById('challengeModal');
        if (existingModal) {
            existingModal.remove();
        }
        
        const modal = document.createElement('div');
        modal.id = 'challengeModal';
        modal.className = 'modal-overlay';
        modal.style.display = 'flex';
        
        const themeIcon = vocabularyThemes[challenge.theme].icon;
        const createdDate = new Date(challenge.createdAt).toLocaleDateString('ko-KR');
        
        modal.innerHTML = `
            <div class="modal-content challenge-modal-content">
                <div class="challenge-header">
                    <h2>ğŸ¯ ë„ì „ì¥ì´ ë„ì°©í–ˆì–´ìš”!</h2>
                </div>
                
                <div class="challenge-info">
                    <div class="challenge-theme">
                        <span class="challenge-theme-icon">${themeIcon}</span>
                        <div class="challenge-theme-name">${challenge.themeName}</div>
                    </div>
                    
                    <div class="challenge-target">
                        <div class="challenge-label">ëª©í‘œ ì ìˆ˜</div>
                        <div class="challenge-score">${challenge.targetScore}ì </div>
                    </div>
                    
                    <div class="challenge-message">
                        <p>ì¹œêµ¬ê°€ ${challenge.themeName} í…Œë§ˆì—ì„œ <strong>${challenge.targetScore}ì </strong>ì„ ë‹¬ì„±í–ˆì–´ìš”!</p>
                        <p>ì´ ê¸°ë¡ì„ ë„˜ì–´ì„œ ë„ì „ì— ì„±ê³µí•´ë³´ì„¸ìš”! ğŸ†</p>
                    </div>
                    
                    <div class="challenge-date">
                        ë„ì „ì¥ ìƒì„±ì¼: ${createdDate}
                    </div>
                </div>
                
                <div class="challenge-actions">
                    <button class="action-btn primary" id="acceptChallengeBtn">
                        ğŸ”¥ ë„ì „ ìˆ˜ë½í•˜ê¸°
                    </button>
                    <button class="action-btn secondary" id="declineChallengeBtn">
                        ë‚˜ì¤‘ì— í•˜ê¸°
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
        document.getElementById('acceptChallengeBtn').onclick = () => {
            modal.remove();
            this.acceptChallenge(challenge);
        };
        
        document.getElementById('declineChallengeBtn').onclick = () => {
            modal.remove();
            window.history.replaceState({}, document.title, window.location.pathname);
            this.showThemeSelector();
        };
        
        // ë°°ê²½ í´ë¦­ìœ¼ë¡œ ë‹«ê¸°
        modal.onclick = (e) => {
            if (e.target === modal) {
                modal.remove();
                window.history.replaceState({}, document.title, window.location.pathname);
                this.showThemeSelector();
            }
        };
    }
    
    acceptChallenge(challenge) {
        // ì±Œë¦°ì§€ ëª¨ë“œë¡œ ê²Œì„ ì‹œì‘
        this.challengeMode = true;
        this.currentChallenge = challenge;
        
        // í•´ë‹¹ í…Œë§ˆë¡œ ë°”ë¡œ ì‹œì‘
        this.selectTheme(challenge.theme);
        
        // ì±Œë¦°ì§€ ëª¨ë“œ UI í‘œì‹œ
        this.updateChallengeUI();
    }
    
    updateChallengeUI() {
        if (this.challengeMode && this.currentChallenge) {
            // í…Œë§ˆ ë¼ë²¨ ì—…ë°ì´íŠ¸
            this.currentThemeLabel.textContent = `${this.currentChallenge.themeName} (ë„ì „ ëª¨ë“œ ğŸ¯)`;
            
            // í—¤ë”ì— ë„ì „ ì •ë³´ ì¶”ê°€
            const challengeInfo = document.createElement('div');
            challengeInfo.className = 'challenge-info-bar';
            challengeInfo.innerHTML = `
                <div class="challenge-target-info">
                    ğŸ¯ ëª©í‘œ: ${this.currentChallenge.targetScore}ì  ë„˜ê¸°
                </div>
            `;
            
            // ê¸°ì¡´ ì±Œë¦°ì§€ ì •ë³´ê°€ ìˆìœ¼ë©´ ì œê±°
            const existingInfo = document.querySelector('.challenge-info-bar');
            if (existingInfo) {
                existingInfo.remove();
            }
            
            // í˜„ì¬ í…Œë§ˆ ì„¹ì…˜ì— ì¶”ê°€
            const currentThemeSection = document.querySelector('.current-theme');
            currentThemeSection.appendChild(challengeInfo);
        }
    }
    
    checkChallengeSuccess(finalScore) {
        if (this.challengeMode && this.currentChallenge) {
            const success = finalScore > this.currentChallenge.targetScore;
            this.showChallengeResult(finalScore, success);
            return true;
        }
        return false;
    }
    
    showChallengeResult(finalScore, success) {
        setTimeout(() => {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.style.display = 'flex';
            
            const resultIcon = success ? 'ğŸ†' : 'ğŸ˜…';
            const resultTitle = success ? 'ë„ì „ ì„±ê³µ!' : 'ë„ì „ ì‹¤íŒ¨...';
            const resultMessage = success 
                ? `ì¶•í•˜í•©ë‹ˆë‹¤! ${this.currentChallenge.targetScore}ì ì„ ë„˜ì–´ ${finalScore}ì ì„ ë‹¬ì„±í–ˆì–´ìš”!`
                : `ì•„ì‰½ê²Œë„ ${this.currentChallenge.targetScore}ì ì„ ë„˜ì§€ ëª»í–ˆì–´ìš”. ${finalScore}ì ìœ¼ë¡œ ë„ì „ ì‹¤íŒ¨! ë‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”!`;
            
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="completion-celebration">${resultIcon}</div>
                    <h2 class="completion-title">${resultTitle}</h2>
                    <div class="challenge-result-info">
                        <div class="result-scores">
                            <div class="score-comparison">
                                <div class="target-score">
                                    <span class="score-label">ëª©í‘œ ì ìˆ˜</span>
                                    <span class="score-value">${this.currentChallenge.targetScore}ì </span>
                                </div>
                                <div class="vs">VS</div>
                                <div class="my-score ${success ? 'success' : 'fail'}">
                                    <span class="score-label">ë‚´ ì ìˆ˜</span>
                                    <span class="score-value">${finalScore}ì </span>
                                </div>
                            </div>
                        </div>
                        <p class="result-message">${resultMessage}</p>
                    </div>
                    <div class="completion-actions">
                        <button class="action-btn primary" id="shareResultBtn">
                            ğŸ“± ê²°ê³¼ ê³µìœ í•˜ê¸°
                        </button>
                        <button class="action-btn secondary" id="retrychallengeBtn">
                            ğŸ”„ ë‹¤ì‹œ ë„ì „í•˜ê¸°
                        </button>
                        <button class="action-btn secondary" id="backToMainBtn">
                            ğŸ  ë©”ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
            document.getElementById('shareResultBtn').onclick = () => {
                this.shareChallengeResult(finalScore, success);
            };
            
            document.getElementById('retrychallengeBtn').onclick = () => {
                modal.remove();
                this.selectTheme(this.currentChallenge.theme);
            };
            
            document.getElementById('backToMainBtn').onclick = () => {
                modal.remove();
                this.challengeMode = false;
                this.currentChallenge = null;
                window.history.replaceState({}, document.title, window.location.pathname);
                this.showThemeSelector();
            };
        }, 500);
    }
    
    async shareChallengeResult(myScore, success) {
        try {
            const imageBlob = await this.generateChallengeResultCard(myScore, success);
            
            if (navigator.share && navigator.canShare && navigator.canShare({ files: [new File([imageBlob], 'result.png', { type: 'image/png' })] })) {
                const file = new File([imageBlob], 'challenge-result.png', { type: 'image/png' });
                await navigator.share({
                    title: 'ğŸ¯ ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„° - ë„ì „ ê²°ê³¼',
                    text: success ? 'ë„ì „ì— ì„±ê³µí–ˆì–´ìš”! ğŸ†' : 'ì•„ì‰½ê²Œ ì‹¤íŒ¨í–ˆì§€ë§Œ ë‹¤ì‹œ ë„ì „í• ê²Œìš”! ğŸ’ª',
                    files: [file]
                });
            } else {
                this.downloadScoreCard(imageBlob, `ë„ì „ê²°ê³¼_${success ? 'ì„±ê³µ' : 'ì‹¤íŒ¨'}_${myScore}ì .png`);
                this.showToast('ğŸ“¸ ë„ì „ ê²°ê³¼ê°€ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!');
            }
        } catch (error) {
            console.error('Error sharing result:', error);
            const resultText = success 
                ? `ğŸ† ë„ì „ ì„±ê³µ! ${this.currentChallenge.themeName}ì—ì„œ ${myScore}ì  ë‹¬ì„±! ëª©í‘œ ${this.currentChallenge.targetScore}ì ì„ ë„˜ì—ˆì–´ìš”!`
                : `ğŸ˜… ë„ì „ ì‹¤íŒ¨... ${this.currentChallenge.themeName}ì—ì„œ ${myScore}ì . ëª©í‘œ ${this.currentChallenge.targetScore}ì ì— ì¡°ê¸ˆ ëª» ë¯¸ì³¤ì–´ìš”!`;
            this.fallbackShare(resultText, window.location.origin + window.location.pathname);
        }
    }
    
    async generateChallengeResultCard(myScore, success) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = 800;
        canvas.height = 800;
        
        const themeColors = this.getThemeColors(this.currentChallenge.theme);
        const themeIcon = vocabularyThemes[this.currentChallenge.theme].icon;
        
        // ë°°ê²½ (ì„±ê³µ/ì‹¤íŒ¨ì— ë”°ë¥¸ ë‹¤ë¥¸ ìƒ‰ìƒ)
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        if (success) {
            gradient.addColorStop(0, '#00d2ff');
            gradient.addColorStop(1, '#3a7bd5');
        } else {
            gradient.addColorStop(0, '#ff9a9e');
            gradient.addColorStop(1, '#fad0c4');
        }
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // ì¹´ë“œ ë°°ê²½
        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.roundRect(50, 80, canvas.width - 100, canvas.height - 160, 30);
        ctx.fill();
        
        // ê²°ê³¼ ì•„ì´ì½˜ ë° ì œëª©
        ctx.font = '80px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(success ? 'ğŸ†' : 'ğŸ˜…', canvas.width / 2, 180);
        
        ctx.fillStyle = success ? '#27ae60' : '#e74c3c';
        ctx.font = 'bold 42px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillText(success ? 'ë„ì „ ì„±ê³µ!' : 'ë„ì „ ì‹¤íŒ¨', canvas.width / 2, 240);
        
        // í…Œë§ˆ ì •ë³´
        ctx.font = '40px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = '#2c3e50';
        ctx.fillText(themeIcon, canvas.width / 2, 310);
        
        ctx.font = 'bold 28px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillText(this.currentChallenge.themeName, canvas.width / 2, 350);
        
        // ì ìˆ˜ ë¹„êµ
        ctx.font = 'bold 24px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = '#666';
        ctx.fillText('ëª©í‘œ', 250, 420);
        ctx.fillText('ë‚´ ê²°ê³¼', 550, 420);
        
        ctx.font = 'bold 60px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = '#999';
        ctx.fillText(`${this.currentChallenge.targetScore}ì `, 250, 480);
        
        ctx.fillStyle = success ? '#27ae60' : '#e74c3c';
        ctx.fillText(`${myScore}ì `, 550, 480);
        
        // VS
        ctx.font = 'bold 32px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = '#333';
        ctx.fillText('VS', canvas.width / 2, 465);
        
        // ê²°ê³¼ ë©”ì‹œì§€
        ctx.font = 'bold 24px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = '#666';
        const message = success ? 'ëª©í‘œë¥¼ ë„˜ì–´ ë„ì „ì— ì„±ê³µí–ˆì–´ìš”!' : 'ì•„ì‰½ì§€ë§Œ ë‹¤ìŒ ê¸°íšŒì—! ğŸ’ª';
        ctx.fillText(message, canvas.width / 2, 560);
        
        // ì•± ì •ë³´
        ctx.font = '24px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillStyle = '#999';
        ctx.fillText('ì˜ì–´ ë‹¨ì–´ ë§ˆìŠ¤í„°', canvas.width / 2, 650);
        ctx.font = '20px "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif';
        ctx.fillText('prepaid114.github.io/prepaid114', canvas.width / 2, 690);
        
        return new Promise(resolve => {
            canvas.toBlob(resolve, 'image/png', 0.9);
        });
    }
    
    initElements() {
        console.log('Initializing elements...');
        
        this.themeSelector = document.getElementById('themeSelector');
        this.themeGrid = document.getElementById('themeGrid');
        this.mainContent = document.getElementById('mainContent');
        this.currentThemeLabel = document.getElementById('currentTheme');
        this.changeThemeBtn = document.getElementById('changeThemeBtn');
        this.wordElement = document.getElementById('currentWord');
        this.wordTypeElement = document.getElementById('wordType');
        this.choicesSection = document.getElementById('choicesSection');
        this.nextBtn = document.getElementById('nextBtn');
        this.feedbackElement = document.getElementById('feedback');
        this.scoreElement = document.getElementById('score');
        this.accuracyElement = document.getElementById('accuracy');
        this.progressFill = document.getElementById('progressFill');
        this.pronunciationBtn = document.getElementById('pronunciationBtn');
        this.autoAdvanceToggle = document.getElementById('autoAdvanceToggle');
        this.questionProgress = document.getElementById('questionProgress');
        
        // Statistics dashboard elements
        this.statsBtn = document.getElementById('statsBtn');
        this.statsDashboard = document.getElementById('statsDashboard');
        this.closeStatsBtn = document.getElementById('closeStatsBtn');
        
        // Social feature elements
        this.shareScoreBtn = document.getElementById('shareScoreBtn');
        this.shareStatsBtn = document.getElementById('shareStatsBtn');
        this.challengeFriendsBtn = document.getElementById('challengeFriendsBtn');
        this.copyLinkBtn = document.getElementById('copyLinkBtn');
        
        // Leaderboard elements
        this.saveToLeaderboardBtn = document.getElementById('saveToLeaderboardBtn');
        this.nicknameModal = document.getElementById('nicknameModal');
        this.leaderboardModal = document.getElementById('leaderboardModal');
        this.nicknameInput = document.getElementById('nicknameInput');
        this.saveNicknameBtn = document.getElementById('saveNicknameBtn');
        this.cancelNicknameBtn = document.getElementById('cancelNicknameBtn');
        this.closeLeaderboardBtn = document.getElementById('closeLeaderboardBtn');
        this.connectionStatus = document.getElementById('connectionStatus');
        
        // Log element states for debugging
        console.log('Elements initialized:', {
            themeSelector: !!this.themeSelector,
            themeGrid: !!this.themeGrid,
            mainContent: !!this.mainContent
        });
        
        // Verify critical elements exist
        if (!this.themeSelector || !this.themeGrid || !this.mainContent) {
            console.error('Critical elements missing:', {
                themeSelector: this.themeSelector,
                themeGrid: this.themeGrid,
                mainContent: this.mainContent
            });
            throw new Error('Critical DOM elements not found');
        }
    }
    
    initVoice() {
        // Wait for voices to load
        const setVoice = () => {
            const voices = this.speechSynthesis.getVoices();
            console.log('Available voices:', voices.map(v => `${v.name} (${v.lang})`));
            
            // Try to find the best English voice
            const englishVoices = voices.filter(voice => 
                voice.lang.startsWith('en-') && 
                (voice.name.includes('Google') || 
                 voice.name.includes('Microsoft') || 
                 voice.name.includes('native') ||
                 voice.name.includes('US') ||
                 voice.name.includes('UK'))
            );
            
            // Prefer US English voices
            this.voice = englishVoices.find(voice => voice.lang === 'en-US') ||
                        englishVoices.find(voice => voice.lang === 'en-GB') ||
                        englishVoices[0] ||
                        voices.find(voice => voice.lang.startsWith('en')) ||
                        voices[0];
                        
            console.log('Selected voice:', this.voice?.name, this.voice?.lang);
        };
        
        if (this.speechSynthesis.getVoices().length > 0) {
            setVoice();
        } else {
            this.speechSynthesis.addEventListener('voiceschanged', setVoice);
        }
    }
    
    bindEvents() {
        this.changeThemeBtn.addEventListener('click', () => this.showThemeSelector());
        this.nextBtn.addEventListener('click', () => this.nextWord());
        this.pronunciationBtn.addEventListener('click', () => this.pronounceWord());
        this.autoAdvanceToggle.addEventListener('change', (e) => {
            this.autoAdvanceEnabled = e.target.checked;
        });
        
        // Statistics dashboard events
        this.statsBtn.addEventListener('click', () => this.showStatsDashboard());
        this.closeStatsBtn.addEventListener('click', () => this.hideStatsDashboard());
        
        // Social feature events
        this.shareStatsBtn.addEventListener('click', () => this.shareStats());
        this.challengeFriendsBtn.addEventListener('click', () => this.challengeFriends());
        this.copyLinkBtn.addEventListener('click', () => this.copyAppLink());
        
        // Leaderboard events
        if (this.saveToLeaderboardBtn) {
            this.saveToLeaderboardBtn.addEventListener('click', () => this.showNicknameModal());
        }
        
        if (this.saveNicknameBtn) {
            this.saveNicknameBtn.addEventListener('click', () => this.saveToLeaderboard());
        }
        
        if (this.cancelNicknameBtn) {
            this.cancelNicknameBtn.addEventListener('click', () => this.hideNicknameModal());
        }
        
        if (this.closeLeaderboardBtn) {
            this.closeLeaderboardBtn.addEventListener('click', () => this.hideLeaderboardModal());
        }
        
        // Choice selection
        this.choicesSection.addEventListener('click', (e) => {
            const choiceItem = e.target.closest('.choice-item');
            if (choiceItem && !choiceItem.classList.contains('correct') && !choiceItem.classList.contains('incorrect')) {
                this.selectChoice(parseInt(choiceItem.dataset.choice));
            }
        });
        
        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (this.mainContent.style.display !== 'none') {
                if (e.key >= '1' && e.key <= '4') {
                    const choiceIndex = parseInt(e.key) - 1;
                    this.selectChoice(choiceIndex);
                } else if (e.key === 'Enter' && this.nextBtn.style.display !== 'none') {
                    this.nextWord();
                }
            }
        });
    }
    
    showThemeSelector() {
        console.log('Showing theme selector...');
        this.themeSelector.style.display = 'block';
        this.mainContent.style.display = 'none';
        this.renderThemes();
    }
    
    renderThemes() {
        console.log('renderThemes called');
        console.log('themeGrid element:', this.themeGrid);
        
        if (!this.themeGrid) {
            console.error('themeGrid element not found');
            return;
        }
        
        this.themeGrid.innerHTML = '';
        
        try {
            Object.keys(vocabularyThemes).forEach(themeKey => {
                const theme = vocabularyThemes[themeKey];
                const themeProgress = this.userProgress.completedThemes[themeKey];
                const bestScore = this.userProgress.bestScores[themeKey] || 0;
                console.log(`Creating theme card for: ${themeKey}`, theme);
                
                const themeCard = document.createElement('button');
                themeCard.className = `theme-card ${themeKey}`;
                
                const wrongAnswersCount = Object.keys(this.userProgress.wrongAnswers[themeKey] || {}).length;
                
                let progressInfo = '';
                if (themeProgress && themeProgress.timesCompleted > 0) {
                    progressInfo = `
                        <div class="theme-progress">
                            <div class="best-score">ìµœê³ : ${bestScore}ì </div>
                            <div class="completion-count">${themeProgress.timesCompleted}íšŒ ì™„ì£¼</div>
                        </div>
                    `;
                }
                
                let reviewButton = '';
                if (wrongAnswersCount > 0) {
                    reviewButton = `
                        <button class="review-btn" data-theme="${themeKey}">
                            ë³µìŠµ (${wrongAnswersCount}ê°œ)
                        </button>
                    `;
                }
                
                themeCard.innerHTML = `
                    <span class="theme-icon">${theme.icon}</span>
                    <div class="theme-title">${theme.name}</div>
                    <div class="theme-count">${theme.words.length}ê°œ ë‹¨ì–´</div>
                    ${progressInfo}
                    ${reviewButton}
                `;
                
                themeCard.addEventListener('click', () => this.selectTheme(themeKey));
                
                // Add review button event listener if exists
                const reviewBtn = themeCard.querySelector('.review-btn');
                if (reviewBtn) {
                    reviewBtn.addEventListener('click', (event) => {
                        event.stopPropagation();
                        this.startReview(themeKey);
                    });
                }
                
                this.themeGrid.appendChild(themeCard);
                console.log(`Added theme card: ${themeKey}`);
            });
            
            console.log(`Total theme cards created: ${this.themeGrid.children.length}`);
            
            // Force layout refresh
            this.themeGrid.style.display = 'none';
            this.themeGrid.offsetHeight; // Trigger reflow
            this.themeGrid.style.display = 'grid';
            
        } catch (error) {
            console.error('Error in renderThemes:', error);
            this.themeGrid.innerHTML = '<div style="color: red; text-align: center; padding: 20px;">í…Œë§ˆ ë¡œë”© ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</div>';
        }
    }
    
    selectTheme(themeKey) {
        this.currentTheme = themeKey;
        this.usedIndices = [];
        this.totalQuestions = 0;
        this.correctAnswers = 0;
        
        // Reset session stats for new theme
        this.sessionStats = {
            wordsLearned: 0,
            correctAnswers: 0,
            totalAnswers: 0,
            startTime: Date.now(),
            questionStartTime: null,
            actualStudyTime: 0
        };
        
        this.currentThemeLabel.textContent = vocabularyThemes[themeKey].name;
        this.updateScore();
        
        this.themeSelector.style.display = 'none';
        this.mainContent.style.display = 'block';
        
        this.loadNewWord();
    }
    
    getRandomWordIndex() {
        const currentWords = vocabularyThemes[this.currentTheme].words;
        
        if (this.usedIndices.length >= currentWords.length) {
            // All words completed - show completion modal
            this.showCompletionModal();
            return null;
        }
        
        let randomIndex;
        do {
            randomIndex = Math.floor(Math.random() * currentWords.length);
        } while (this.usedIndices.includes(randomIndex));
        
        this.usedIndices.push(randomIndex);
        return randomIndex;
    }
    
    generateChoices(correctMeaning) {
        const currentWords = vocabularyThemes[this.currentTheme].words;
        const choices = [correctMeaning];
        
        // Get all possible meanings except the correct one
        const otherMeanings = currentWords
            .filter(word => word.meaning !== correctMeaning)
            .map(word => word.meaning);
        
        // Add random wrong choices
        while (choices.length < 4 && otherMeanings.length > 0) {
            const randomIndex = Math.floor(Math.random() * otherMeanings.length);
            const randomMeaning = otherMeanings[randomIndex];
            
            if (!choices.includes(randomMeaning)) {
                choices.push(randomMeaning);
            }
            otherMeanings.splice(randomIndex, 1);
        }
        
        // If we don't have enough choices from current theme, add from other themes
        if (choices.length < 4) {
            const allOtherMeanings = [];
            Object.keys(vocabularyThemes).forEach(themeKey => {
                if (themeKey !== this.currentTheme) {
                    vocabularyThemes[themeKey].words.forEach(word => {
                        if (!choices.includes(word.meaning)) {
                            allOtherMeanings.push(word.meaning);
                        }
                    });
                }
            });
            
            while (choices.length < 4 && allOtherMeanings.length > 0) {
                const randomIndex = Math.floor(Math.random() * allOtherMeanings.length);
                choices.push(allOtherMeanings[randomIndex]);
                allOtherMeanings.splice(randomIndex, 1);
            }
        }
        
        // Shuffle choices
        const shuffledChoices = [...choices];
        for (let i = shuffledChoices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffledChoices[i], shuffledChoices[j]] = [shuffledChoices[j], shuffledChoices[i]];
        }
        
        return {
            choices: shuffledChoices,
            correctIndex: shuffledChoices.indexOf(correctMeaning)
        };
    }
    
    loadNewWord() {
        this.currentWordIndex = this.getRandomWordIndex();
        
        if (this.currentWordIndex === null) {
            // Theme completed
            this.showCompletionModal();
            return;
        }
        
        const currentWord = vocabularyThemes[this.currentTheme].words[this.currentWordIndex];
        
        this.wordElement.textContent = currentWord.word;
        this.wordTypeElement.textContent = currentWord.type;
        
        // Generate choices
        const choiceData = this.generateChoices(currentWord.meaning);
        this.currentChoices = choiceData.choices;
        this.correctChoiceIndex = choiceData.correctIndex;
        this.selectedChoice = null;
        
        // Update choice elements
        for (let i = 0; i < 4; i++) {
            const choiceElement = document.getElementById(`choice${i}`);
            const choiceItem = choiceElement.parentElement;
            
            choiceElement.textContent = this.currentChoices[i] || '';
            choiceItem.className = 'choice-item';
            // Remove all selection/result classes
            choiceItem.classList.remove('correct', 'incorrect', 'selected');
        }
        
        this.feedbackElement.textContent = '';
        this.feedbackElement.className = 'feedback';
        this.nextBtn.style.display = 'none';
        
        // Update question progress counter
        this.updateQuestionProgress();
        this.updateProgress();
        
        // Record question start time for accurate study time tracking
        this.sessionStats.questionStartTime = Date.now();
    }
    
    updateQuestionProgress() {
        if (this.questionProgress) {
            const currentQuestion = this.totalQuestions + 1;
            const totalQuestions = this.reviewMode ? this.reviewWords.length : vocabularyThemes[this.currentTheme].words.length;
            this.questionProgress.textContent = `ë¬¸ì œ ${currentQuestion}/${totalQuestions}`;
        }
    }
    
    selectChoice(choiceIndex) {
        if (this.selectedChoice !== null) return;
        
        this.selectedChoice = choiceIndex;
        this.totalQuestions++;
        
        // Record actual study time for this question
        if (this.sessionStats.questionStartTime) {
            const questionTime = Date.now() - this.sessionStats.questionStartTime;
            this.sessionStats.actualStudyTime += questionTime;
        }
        
        // Show results
        for (let i = 0; i < 4; i++) {
            const choiceItem = document.querySelector(`[data-choice="${i}"]`);
            
            if (i === this.correctChoiceIndex) {
                choiceItem.classList.add('correct');
            } else if (i === choiceIndex) {
                choiceItem.classList.add('incorrect');
            }
        }
        
        const isCorrect = choiceIndex === this.correctChoiceIndex;
        
        if (isCorrect) {
            this.correctAnswers++;
            this.showFeedback('ì •ë‹µì…ë‹ˆë‹¤! ğŸ‰', 'correct');
        } else {
            // Track wrong answer for review
            this.trackWrongAnswer();
            this.showFeedback(`í‹€ë ¸ìŠµë‹ˆë‹¤. ğŸ˜” ì •ë‹µ: ${this.currentChoices[this.correctChoiceIndex]}`, 'incorrect');
        }
        
        this.updateScore();
        this.nextBtn.style.display = 'inline-block';
        
        // Auto advance after 2 seconds if enabled
        if (this.autoAdvanceEnabled) {
            this.autoAdvanceTimeout = setTimeout(() => {
                this.nextWord();
            }, 2000);
        }
    }
    
    showFeedback(message, type) {
        this.feedbackElement.textContent = message;
        this.feedbackElement.className = `feedback ${type}`;
    }
    
    nextWord() {
        // Clear any pending auto-advance timeout
        if (this.autoAdvanceTimeout) {
            clearTimeout(this.autoAdvanceTimeout);
            this.autoAdvanceTimeout = null;
        }
        
        if (this.reviewMode) {
            this.loadReviewWord();
        } else {
            this.loadNewWord();
        }
    }
    
    pronounceWord() {
        if (this.speechSynthesis && this.voice) {
            // Cancel any ongoing speech
            this.speechSynthesis.cancel();
            
            // Get the word currently displayed on screen (works for both normal and review mode)
            const word = this.wordElement.textContent;
            const utterance = new SpeechSynthesisUtterance(word);
            
            utterance.voice = this.voice;
            utterance.rate = 0.7; // Slower for clarity
            utterance.pitch = 1;
            utterance.volume = 1;
            utterance.lang = 'en-US'; // Force English US
            
            console.log(`Pronouncing: ${word} with voice: ${this.voice.name}`);
            this.speechSynthesis.speak(utterance);
        } else {
            console.warn('Speech synthesis not available or voice not set');
        }
    }
    
    updateScore() {
        // Calculate score as percentage of correct answers (100 points max)
        const score = this.totalQuestions > 0 ? Math.round((this.correctAnswers / this.totalQuestions) * 100) : 0;
        this.scoreElement.textContent = score;
        // Calculate accuracy as percentage (same as score for clarity)
        const accuracy = this.totalQuestions > 0 ? Math.round((this.correctAnswers / this.totalQuestions) * 100) : 0;
        this.accuracyElement.textContent = `${accuracy}%`;
    }
    
    updateProgress() {
        const currentWords = vocabularyThemes[this.currentTheme].words;
        const progress = (this.usedIndices.length / currentWords.length) * 100;
        this.progressFill.style.width = `${progress}%`;
    }
    
    showCompletionModal() {
        const modal = document.getElementById('completionModal');
        const finalScore = document.getElementById('finalScore');
        const finalAccuracy = document.getElementById('finalAccuracy');
        const completedTheme = document.getElementById('completedTheme');
        const nextThemeBtn = document.getElementById('nextThemeBtn');
        const retryThemeBtn = document.getElementById('retryThemeBtn');
        
        // Update modal content
        const finalScoreValue = this.totalQuestions > 0 ? Math.round((this.correctAnswers / this.totalQuestions) * 100) : 0;
        finalScore.textContent = finalScoreValue;
        const accuracy = this.totalQuestions > 0 ? Math.round((this.correctAnswers / this.totalQuestions) * 100) : 0;
        finalAccuracy.textContent = `${accuracy}%`;
        completedTheme.textContent = vocabularyThemes[this.currentTheme].name;
        
        // Check for challenge completion
        if (this.checkChallengeSuccess(finalScoreValue)) {
            return; // Challenge result modal will be shown instead
        }
        
        // Update user progress
        this.updateProgress(this.currentTheme, finalScoreValue, accuracy);
        
        // Show modal
        modal.style.display = 'flex';
        
        // Bind events
        nextThemeBtn.onclick = () => {
            modal.style.display = 'none';
            this.showThemeSelector();
        };
        
        retryThemeBtn.onclick = () => {
            modal.style.display = 'none';
            this.selectTheme(this.currentTheme);
        };
        
        this.shareScoreBtn.onclick = () => {
            this.shareScore(finalScoreValue, accuracy, vocabularyThemes[this.currentTheme].name);
        };
        
        // Close modal on background click
        modal.onclick = (e) => {
            if (e.target === modal) {
                modal.style.display = 'none';
                this.showThemeSelector();
            }
        };
    }
}

// Global quiz instance for review functionality
let quiz;

// Ensure the app initializes even if there are timing issues
let initAttempts = 0;
const maxInitAttempts = 3;

function initializeApp() {
    console.log(`DOM loaded, starting VocabularyQuiz... (attempt ${initAttempts + 1})`);
    
    try {
        // Check if critical elements exist
        const themeGrid = document.getElementById('themeGrid');
        const themeSelector = document.getElementById('themeSelector');
        const mainContent = document.getElementById('mainContent');
        
        if (!themeGrid || !themeSelector || !mainContent) {
            console.warn('Critical elements not found, retrying...');
            initAttempts++;
            if (initAttempts < maxInitAttempts) {
                setTimeout(initializeApp, 100);
                return;
            } else {
                throw new Error('Critical DOM elements not found after multiple attempts');
            }
        }
        
        window.quiz = new VocabularyQuiz();
        console.log('VocabularyQuiz initialized successfully');
    } catch (error) {
        console.error('Error initializing VocabularyQuiz:', error);
        console.error('Error stack:', error.stack);
        
        // Fallback: create a basic error display and manual theme buttons
        const themeGrid = document.getElementById('themeGrid');
        if (themeGrid) {
            themeGrid.innerHTML = `
                <div style="color: red; text-align: center; padding: 20px; grid-column: 1/-1;">
                    ë¡œë”© ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. 
                    <br><small>ì˜¤ë¥˜: ${error.message}</small>
                    <br><br>
                    <button onclick="location.reload()" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer;">
                        ìƒˆë¡œê³ ì¹¨
                    </button>
                </div>
            `;
        }
    }
    
    // Leaderboard Management Methods
    async initializeLeaderboard() {
        console.log('Initializing leaderboard...');
        if (window.leaderboardManager) {
            console.log('LeaderboardManager found, initializing...');
            await window.leaderboardManager.initialize();
            this.updateConnectionStatus();
        } else {
            console.warn('LeaderboardManager not found');
        }
    }
    
    updateConnectionStatus() {
        if (!this.connectionStatus) return;
        
        const statusDot = this.connectionStatus.querySelector('.status-dot');
        const statusText = this.connectionStatus.querySelector('.status-text');
        
        if (window.leaderboardManager?.isConnected()) {
            statusDot.className = 'status-dot online';
            statusText.textContent = 'ì˜¨ë¼ì¸ ëª¨ë“œ';
        } else {
            statusDot.className = 'status-dot offline';
            statusText.textContent = 'ì˜¤í”„ë¼ì¸ ëª¨ë“œ';
        }
    }
    
    showNicknameModal() {
        console.log('showNicknameModal called');
        
        if (!this.nicknameModal) {
            console.warn('nicknameModal element not found');
            return;
        }
        
        // Update connection status
        this.updateConnectionStatus();
        
        // Check if user already has a nickname
        const currentUser = window.leaderboardManager?.getCurrentUser();
        if (currentUser) {
            this.nicknameInput.value = currentUser.nickname;
        }
        
        console.log('Showing nickname modal');
        this.nicknameModal.style.display = 'flex';
        
        if (this.nicknameInput) {
            this.nicknameInput.focus();
            
            // ì‹¤ì‹œê°„ ë‹‰ë„¤ì„ ì²´í¬
            let checkTimeout;
            this.nicknameInput.oninput = (e) => {
                clearTimeout(checkTimeout);
                const nickname = e.target.value.trim();
                
                // ë‹‰ë„¤ì„ ê¸¸ì´ ì²´í¬
                if (nickname.length > 10) {
                    this.showNicknameStatus('ë‹‰ë„¤ì„ì€ 10ì ì´í•˜ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.', 'error');
                    return;
                }
                
                if (nickname.length < 2) {
                    this.showNicknameStatus('', '');
                    return;
                }
                
                // 500ms í›„ ì¤‘ë³µ ì²´í¬
                checkTimeout = setTimeout(async () => {
                    await this.checkNicknameAvailability(nickname);
                }, 500);
            };
            
            // Enter key to save
            this.nicknameInput.onkeypress = (e) => {
                if (e.key === 'Enter') {
                    console.log('Enter key pressed');
                    this.saveToLeaderboard();
                }
            };
        }
        
        // Add background click to close modal
        this.nicknameModal.onclick = (e) => {
            if (e.target === this.nicknameModal) {
                console.log('Modal background clicked');
                this.hideNicknameModal();
            }
        };
    }
    
    async checkNicknameAvailability(nickname) {
        try {
            this.showNicknameStatus('í™•ì¸ ì¤‘...', 'checking');
            const isAvailable = await window.leaderboardManager.isNicknameAvailable(nickname);
            
            if (isAvailable) {
                this.showNicknameStatus('ì‚¬ìš© ê°€ëŠ¥í•œ ë‹‰ë„¤ì„ì…ë‹ˆë‹¤.', 'success');
            } else {
                this.showNicknameStatus('ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ë‹‰ë„¤ì„ì…ë‹ˆë‹¤.', 'error');
            }
        } catch (error) {
            console.warn('Nickname availability check failed:', error);
            this.showNicknameStatus('', '');
        }
    }
    
    showNicknameStatus(message, type) {
        const statusElement = this.connectionStatus.querySelector('.status-text');
        const statusDot = this.connectionStatus.querySelector('.status-dot');
        
        if (statusElement) {
            statusElement.textContent = message;
        }
        
        if (statusDot) {
            statusDot.className = 'status-dot';
            if (type === 'success') {
                statusDot.classList.add('online');
            } else if (type === 'error') {
                statusDot.classList.add('offline');
            } else if (type === 'checking') {
                statusDot.style.background = '#f39c12';
            } else {
                // Reset to connection status
                this.updateConnectionStatus();
                return;
            }
        }
    }
    
    hideNicknameModal() {
        if (this.nicknameModal) {
            this.nicknameModal.style.display = 'none';
            this.nicknameInput.value = '';
            // Reset status display
            this.updateConnectionStatus();
        }
    }
    
    async saveToLeaderboard() {
        console.log('saveToLeaderboard function called!');
        
        if (!this.nicknameInput) {
            console.error('nicknameInput not found');
            alert('ë‹‰ë„¤ì„ ì…ë ¥ í•„ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            return;
        }
        
        const nickname = this.nicknameInput.value.trim();
        console.log('Nickname entered:', nickname);
        
        if (!nickname || nickname.length < 2) {
            console.log('Nickname too short:', nickname);
            alert('ë‹‰ë„¤ì„ì€ 2ì ì´ìƒ ì…ë ¥í•´ì£¼ì„¸ìš”.');
            return;
        }

        if (nickname.length > 10) {
            alert('ë‹‰ë„¤ì„ì€ 10ì ì´í•˜ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.');
            return;
        }

        // ë‹‰ë„¤ì„ ì¤‘ë³µ ì²´í¬
        console.log('Checking nickname availability...');
        try {
            const isAvailable = await window.leaderboardManager.isNicknameAvailable(nickname);
            if (!isAvailable) {
                alert(`"${nickname}"ì€(ëŠ”) ì´ë¯¸ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤.\në‹¤ë¥¸ ë‹‰ë„¤ì„ì„ ì‚¬ìš©í•´ì£¼ì„¸ìš”.`);
                this.nicknameInput.focus();
                return;
            }
            console.log('Nickname is available');
        } catch (error) {
            console.warn('Nickname check failed:', error);
            // ì²´í¬ ì‹¤íŒ¨ ì‹œ ê³„ì† ì§„í–‰
        }
        
        if (!window.leaderboardManager) {
            console.error('leaderboardManager not found');
            alert('ë¦¬ë”ë³´ë“œ ì‹œìŠ¤í…œì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
            return;
        }
        
        console.log('leaderboardManager found, proceeding...');
        
        try {
            // Set user nickname
            console.log('Setting user nickname...');
            window.leaderboardManager.setUser(nickname);
            console.log('User nickname set successfully');
            
            // Prepare score data from current quiz results
            const finalScore = document.getElementById('finalScore')?.textContent || '0';
            const finalAccuracy = document.getElementById('finalAccuracy')?.textContent.replace('%', '') || '0';
            
            console.log('Final score element value:', finalScore);
            console.log('Final accuracy element value:', finalAccuracy);
            console.log('Current theme:', this.currentTheme);
            console.log('Session study time:', this.sessionStats.actualStudyTime);
            
            const scoreData = {
                score: parseInt(finalScore),
                accuracy: parseInt(finalAccuracy),
                theme: this.currentTheme,
                studyTime: this.sessionStats.actualStudyTime
            };
            
            console.log('Score data prepared:', scoreData);
            
            // Save to leaderboard with timeout
            console.log('Calling saveScore...');
            const savePromise = window.leaderboardManager.saveScore(scoreData);
            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Timeout')), 5000)
            );
            
            const result = await Promise.race([savePromise, timeoutPromise]);
            console.log('saveScore result:', result);
            
            this.hideNicknameModal();
            
            if (result.success) {
                if (result.online) {
                    alert('ğŸ‰ ì ìˆ˜ê°€ ì˜¨ë¼ì¸ ë¦¬ë”ë³´ë“œì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
                } else {
                    alert('âœ… ì ìˆ˜ê°€ ë¡œì»¬ì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤. (ì˜¨ë¼ì¸ ì—°ê²° ì‹œ ë™ê¸°í™”ë©ë‹ˆë‹¤)');
                }
                
                // Show leaderboard
                this.showLeaderboardModal();
            } else {
                alert('ì ìˆ˜ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        } catch (error) {
            console.error('Error saving to leaderboard:', error);
            this.hideNicknameModal();
            
            if (error.message === 'Timeout') {
                alert('âš ï¸ ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. ì ìˆ˜ê°€ ë¡œì»¬ì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
            } else {
                alert('ì ìˆ˜ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }
    }
    
    showLeaderboardModal() {
        if (this.leaderboardModal) {
            this.leaderboardModal.style.display = 'flex';
            this.loadLeaderboardData();
        }
    }
    
    hideLeaderboardModal() {
        if (this.leaderboardModal) {
            this.leaderboardModal.style.display = 'none';
        }
    }
    
    async loadLeaderboardData() {
        try {
            const leaderboard = await window.leaderboardManager.getLeaderboard(10);
            this.displayLeaderboard(leaderboard);
        } catch (error) {
            console.error('Failed to load leaderboard:', error);
        }
    }
    
    displayLeaderboard(leaderboard) {
        const globalLeaderboard = document.getElementById('globalLeaderboard');
        if (!globalLeaderboard) return;
        
        if (leaderboard.length === 0) {
            globalLeaderboard.innerHTML = '<div class="loading">ì•„ì§ ë“±ë¡ëœ ì ìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
            return;
        }
        
        globalLeaderboard.innerHTML = leaderboard.map((entry, index) => {
            const rank = index + 1;
            const rankClass = rank === 1 ? 'gold' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : '';
            
            return `
                <div class="leaderboard-item">
                    <div class="leaderboard-rank ${rankClass}">${rank}</div>
                    <div class="leaderboard-info">
                        <div class="leaderboard-nickname">${entry.nickname}</div>
                        <div class="leaderboard-stats">${entry.theme || 'í…Œë§ˆ'} â€¢ ${entry.accuracy || 0}% ì •í™•ë„</div>
                    </div>
                    <div class="leaderboard-score">${entry.score || entry.bestScore}ì </div>
                </div>
            `;
        }).join('');
    }
}

document.addEventListener('DOMContentLoaded', initializeApp);

// Backup initialization for older browsers
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeApp);
} else {
    // DOM is already loaded
    setTimeout(initializeApp, 10);
}